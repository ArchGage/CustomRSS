<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom RSS</title>
  <style>
    /* ── COLOR VARIABLES FOR PURPLE GRADIENT THEME ── */
    :root {
      --bg-page: linear-gradient(135deg, #2e003e, #5e008e);
      --bg-card: #3b003b;
      --bg-card-hover: #5e005e;
      --bg-overlay: linear-gradient(135deg, rgba(46, 0, 62, 0.95), rgba(94, 0, 142, 0.95));
      --bg-info: #4a004a;
      --bg-button: #6a0dad;
      --bg-button-hover: #8f13d9;
      --bg-home-button: #5c005c;
      --bg-home-button-hover: #7e007e;
      --bg-side-menu: #2a002a;
      --bg-backdrop: rgba(0, 0, 0, 0.5);
      --text-primary: #f0e4ff;
      --text-secondary: #d1b3ff;
      --text-accent: #c18cff;
      --overlay-text-bg: rgba(60, 0, 60, 0.9);
      --toast-bg: rgba(0, 0, 0, 0.8);
      --toast-text: #f0e4ff;
      --tab-active-bg: #440044;
      --tab-inactive-bg: #2a002a;
      --live-bar-bg: rgba(0,0,0,0.6);
    }

    /* ── GLOBAL BOX-SIZING & FULL-HEIGHT SETUP ── */
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }

    /* ── BODY & PAGE BACKGROUND ── */
    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg-page);
      background-attachment: fixed;
      background-size: cover;
      color: var(--text-primary);
      margin: 0; padding: 0; overflow-x: hidden;
    }
    h1 { margin: 0; padding: 1rem; font-weight: 400; }

    /* ── LIVE BAR (always at top) ── */
    #liveBar {
      position: sticky; top: 0; z-index: 1000;
      background: var(--live-bar-bg);
      padding: 0.25rem 1rem;
      display: flex; align-items: center; gap: 0.5rem;
      overflow-x: auto;
    }
    #liveBar img {
      width: 32px; height: 32px; border-radius: 50%;
      object-fit: cover; border: 1px solid var(--text-primary);
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    #liveBar img.live {
      border: 2px solid #ff0000;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }

    /* ── HEADER BAR ── */
    .header {
      display: flex; align-items: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.5rem 1rem; position: sticky;
      top: 42px; /* just below liveBar */
      z-index: 999;
    }
    .burger-button {
      font-size: 1.5rem; background: none;
      border: none; color: var(--text-primary);
      cursor: pointer; margin-right: 1rem;
    }
    .main-tabs {
      display: flex; gap: 0.5rem;
    }
    .main-tabs button {
      background: var(--tab-inactive-bg); color: var(--text-primary);
      border: none; border-radius: 4px 4px 0 0;
      padding: 0.5rem 1rem; cursor: pointer;
      font-size: 0.95rem; transition: background 0.2s ease;
    }
    .main-tabs button.active {
      background: var(--tab-active-bg);
    }
    .filter-checkboxes {
      display: flex; flex-wrap: wrap; gap: 1rem;
      margin-left: auto; align-items: center;
    }
    .filter-checkboxes label {
      display: flex; align-items: center;
      font-size: 0.9rem; cursor: pointer;
      color: var(--text-primary);
    }
    .filter-checkboxes label input {
      margin-right: 0.3rem;
      cursor: pointer;
    }
    .filter-categories {
      display: flex; gap: 0.5rem; align-items: center;
      margin-left: 1rem;
    }
    .filter-categories button {
      background: var(--bg-button); color: var(--text-primary);
      border: none; border-radius: 4px;
      padding: 0.5rem 1rem; cursor: pointer;
      font-size: 0.9rem; transition: background 0.2s ease;
    }
    .filter-categories button.active {
      background: var(--bg-home-button);
    }
    .filter-categories button:hover {
      background: var(--bg-button-hover);
    }

    /* ── SIDE MENU BACKDROP ── */
    #sideBackdrop {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-backdrop);
      z-index: 1400; display: none;
    }
    #sideBackdrop.show { display: block; }

    /* ── SIDE MENU (BURGER) ── */
    #sideMenu {
      position: fixed; top: 0; left: 0;
      width: 250px; height: 100vh;
      background: var(--bg-side-menu);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 1500; padding: 1rem;
      box-sizing: border-box;
      display: flex; flex-direction: column;
    }
    #sideMenu.open { transform: translateX(0); }

    .close-arrow {
      align-self: flex-start;
      background: none; border: none;
      color: var(--text-primary);
      font-size: 1.2rem; cursor: pointer;
      margin-bottom: 1rem;
    }

    #sideMenu h2 {
      margin: 0 0 1rem; color: var(--text-primary);
      font-size: 1.2rem;
    }
    .side-controls {
      flex: 1; display: flex; flex-direction: column;
    }
    .side-controls input,
    .side-controls select,
    .side-controls button,
    .side-controls label {
      width: 100%; margin-bottom: 0.75rem;
    }
    .side-controls input[type="text"],
    .side-controls select {
      background: #330033; color: var(--text-primary);
    }
    .side-controls button {
      background: var(--bg-button); color: var(--text-primary);
      padding: 0.5rem; border: none;
      border-radius: 4px; cursor: pointer;
      transition: background 0.2s ease;
    }
    .side-controls button:hover {
      background: var(--bg-button-hover);
    }
    .side-controls label {
      display: flex; align-items: center;
      color: var(--text-primary); cursor: pointer;
    }
    .side-controls label input {
      margin-right: 0.5rem; cursor: pointer;
    }

    /* ── Tabs' content containers ── */
    .tab-content {
      display: none;
      padding-top: 1rem;
    }
    .tab-content.active {
      display: block;
    }

    /* ── PAGE CONTENT (RSS) ── */
    #rssContainer #mainContent { padding: 1rem; }
    .category-block { margin-bottom: 2rem; }
    .category-block h2 {
      margin: 0 0 0.5rem; font-size: 1.3rem;
      color: var(--text-primary);
    }
    .entry-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem; margin-top: 1rem;
    }
    .entry-card {
      background: var(--bg-card); border-radius: 12px;
      overflow: hidden; cursor: pointer;
      transition: background-color 0.2s ease;
      transform-origin: center;
      opacity: 1;
      transform: scale(1);
    }
    .entry-card:hover { background: var(--bg-card-hover); }
    .entry-card a {
      display: block;
      width: 100%;
      height: 100%;
      text-decoration: none;
      color: inherit;
    }
    .thumbnail-wrapper {
      width: 100%; position: relative;
      padding-top: 56.25%; overflow: hidden;
      background: #000;
    }
    .thumbnail-wrapper img {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; object-fit: cover;
    }
    .entry-card p {
      margin: 0.5rem; font-size: 0.95rem;
      color: var(--text-primary); text-overflow: ellipsis;
      overflow: hidden; white-space: nowrap;
      width: 100%; text-align: center; flex-shrink: 0;
    }
    .entry-card .channel-label {
      position: absolute;
      top: 4px; left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: var(--text-secondary);
      font-size: 0.75rem;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .entry-card.watching::after {
      content: "Watching"; position: absolute;
      top: 8px; left: 8px; background: rgba(60, 0, 60, 0.7);
      color: var(--text-primary); padding: 0.25rem 0.5rem;
      font-size: 0.8rem; border-radius: 4px;
    }
    .entry-card.watching {
      opacity: 0.6; pointer-events: none;
    }

    /* ── PLAYER OVERLAY (RSS) ── */
    .player-overlay {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-overlay);
      z-index: 10000; display: none;
      padding: 2rem; box-sizing: border-box;
      overflow: hidden;
    }
    .player-overlay.show {
      display: flex; justify-content: center;
    }
    body.no-scroll { overflow: hidden; }
    .overlay-content {
      display: flex; gap: 1rem;
      justify-content: center; width: 100%;
      height: 100%;
    }
    .left-column {
      flex: 0 0 12.5%; position: relative;
      display: flex; flex-direction: column; align-items: flex-start;
      padding-top: 1rem;
    }
    .left-column .close-arrow {
      margin-left: 0; /* align left */
    }
    .overlay-live-icons {
      margin-top: 1rem;
      display: flex; flex-direction: column; gap: 0.5rem;
      align-items: center;
    }
    .overlay-live-icons img {
      width: 40px; height: 40px; border-radius: 50%;
      object-fit: cover; border: 2px solid var(--text-primary);
      cursor: pointer;
    }
    .video-left {
      flex: 0 0 75%; display: flex;
      flex-direction: column; overflow-y: auto;
      padding-right: 1rem; /* leave room so scrollbar doesn't overlap */
      max-height: 100%;
    }
    .video-wrapper-container {
      position: relative;
      width: 100%; aspect-ratio: 16/9;
      border-radius: 8px; overflow: hidden;
      background: #000; flex-shrink: 0;
      margin-bottom: 1rem;
    }
    iframe, video {
      width: 100%; height: 100%; border: none;
      background: #000;
    }
    .video-info {
      background: var(--bg-info); padding: 1rem;
      border-radius: 8px; width: 100%;
      overflow-y: auto; scrollbar-width: none;
      flex-shrink: 0; margin-bottom: 1rem;
    }
    .video-info::-webkit-scrollbar { width: 0; height: 0; }
    .video-info h2 {
      margin: 0 0 0.5rem; font-size: 1.2rem;
      color: var(--text-primary);
    }
    .video-info p {
      white-space: pre-wrap; margin: 0;
      color: var(--text-secondary); line-height: 1.4;
    }
    .video-info a {
      color: var(--text-accent); text-decoration: underline;
      cursor: pointer;
    }
    .read-more-button {
      color: var(--text-secondary); background: none;
      border: none; font-size: 0.9rem; cursor: pointer;
      margin-top: 0.5rem; padding: 0;
    }
    .read-more-button:hover { text-decoration: underline; }

    /* ── RIGHT COLUMN (unlimited queue) ── */
    .video-right {
      flex: 0 0 12.5%;
      display: flex; flex-direction: column; gap: 0.75rem;
      height: 100%;
      overflow-y: auto;
      padding-right: 0.5rem; /* ensure scrollbar doesn't overlap */
    }
    .video-right::-webkit-scrollbar { width: 6px; }
    .video-right::-webkit-scrollbar-thumb {
      background: rgba(200, 200, 200, 0.3); border-radius: 3px;
    }
    .video-right .entry-card {
      width: 100%;
      aspect-ratio: 16/9;
      position: relative; border-radius: 8px; overflow: hidden;
      background: var(--bg-card);
      display: flex; align-items: flex-end;
      min-height: 12.5%;
    }
    .video-right .entry-card .thumbnail-wrapper {
      width: 100%; position: absolute; padding-top: 56.25%; overflow: hidden;
      background: #000; flex-shrink: 0;
    }
    .video-right .entry-card .thumbnail-wrapper img {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;
      display: block;
    }
    .video-right .entry-card p {
      background: var(--overlay-text-bg); margin: 0; padding: 0.3rem; font-size: 0.7rem;
      color: var(--text-primary); width: 100%; text-align: center; white-space: nowrap;
      text-overflow: ellipsis; overflow: hidden; position: relative;
    }
    .video-right .entry-card .channel-label {
      position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.7); color: var(--text-secondary);
      font-size: 0.6rem; padding: 0.1rem 0.3rem; border-radius: 4px; max-width: 85%;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .video-right .entry-card.watching::after {
      content: "Watching"; position: absolute; top: 6px; left: 6px; background: rgba(60,0,60,0.7);
      color: var(--text-primary); padding: 0.15rem 0.3rem; font-size: 0.6rem; border-radius: 4px;
    }
    .video-right .entry-card.watching {
      opacity: 0.6; pointer-events: none;
    }

    /* ── TOAST NOTIFICATION (for "Patreon skipped") ── */
    #toast {
      position: fixed; top: 1rem; right: 1rem;
      background: var(--toast-bg); color: var(--toast-text);
      padding: 0.75rem 1rem; border-radius: 4px;
      font-size: 0.9rem; opacity: 0; pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 20000;
    }
    #toast.show {
      opacity: 1;
    }

    /* ── MANAGE FEEDS PANEL & BACKDROP ── */
    #manageBackdrop {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-backdrop);
      z-index: 1600; display: none;
    }
    #manageBackdrop.show { display: block; }
    #managePanel {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-side-menu); border-radius: 8px; padding: 1.5rem;
      width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
      z-index: 1601; box-sizing: border-box; display: none;
    }
    #managePanel.show { display: block; }
    #managePanel h2 {
      margin-top: 0; color: var(--text-primary); font-size: 1.5rem;
    }
    .manage-feed-list {
      margin-top: 1rem; display: flex; flex-direction: column; gap: 1rem;
    }
    .manage-feed-item {
      background: var(--bg-card); border-radius: 8px; padding: 0.75rem;
      display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;
    }
    .manage-feed-item input[type="text"] {
      flex: 2; background: #222; color: var(--text-primary); margin-right: 0.5rem;
    }
    .manage-feed-item select {
      flex: 1; background: #222; color: var(--text-primary); margin-right: 0.5rem;
    }
    .manage-feed-item label {
      display: flex; align-items: center; color: var(--text-primary);
      font-size: 0.9rem; margin-right: 0.5rem;
    }
    .manage-feed-item input[type="checkbox"] {
      margin-right: 0.25rem; cursor: pointer;
    }
    .manage-feed-item button {
      background: #cc3333; color: #fff; border: none; border-radius: 4px;
      padding: 0.4rem 0.8rem; cursor: pointer; transition: background 0.2s ease;
    }
    .manage-feed-item button:hover {
      background: #aa1111;
    }

    /* ── TWITCH QUEUE UI (updated) ── */
    #twitchContainer {
      padding: 1rem;
      position: relative;
      z-index: 1;
    }
    #twitchControls {
      display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;
      margin-bottom: 1rem;
    }
    #twitchControls input[type="text"] {
      padding: 0.5rem; border: none; border-radius: 4px;
      background: #330033; color: var(--text-primary); flex: 1;
    }
    #twitchControls button {
      background: var(--bg-button); color: var(--text-primary);
      border: none; border-radius: 4px; padding: 0.5rem 1rem;
      cursor: pointer; transition: background 0.2s ease;
    }
    #twitchControls button:hover {
      background: var(--bg-button-hover);
    }

    /* Draggable circle icons (with drag-over highlight) */
    #twitchList {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      align-items: center;
      position: relative;
      z-index: 2;
    }
    .twitch-icon-wrapper {
      position: relative;
    }
    .twitch-icon-item {
      width: 50px;
      height: 50px;
      position: relative;
      cursor: grab;
    }
    .twitch-icon-item.dragging {
      cursor: grabbing;
      opacity: 0.5;
    }
    .twitch-icon-item img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid var(--text-primary);
      transition: border-color 0.2s ease, transform 0.2s ease;
      object-fit: cover;
      pointer-events: none;
    }
    .twitch-icon-item.live img {
      border-color: #ff0000;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    .twitch-icon-item.drop-target img {
      transform: scale(1.1);
      border-color: var(--text-accent);
      box-shadow: 0 0 15px var(--text-accent);
    }

    #twitchPlayerContainer {
      margin-top: 1.5rem;
      width: 100%; max-width: 800px; aspect-ratio: 16/9;
      background: #000; border-radius: 8px; overflow: hidden;
      position: relative;
    }
    #twitchPlayerContainer iframe {
      width: 100%; height: 100%; border: none;
    }
    #twitchStatus {
      margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);
    }

    .log-button {
      margin-left: 1rem;
      background: #444; color: var(--text-primary);
      border: none; border-radius: 4px;
      padding: 0.4rem 0.8rem; cursor: pointer;
      font-size: 0.9rem; transition: background 0.2s ease;
    }
    .log-button:hover {
      background: #666;
    }

    #version-indicator {
      position: fixed;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.5);
      color: var(--text-secondary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      z-index: 1001;
    }

    /* ── FOLDER FILTER STYLES ── */
    .filter-checkboxes select {
      background: var(--bg-button);
      color: var(--text-primary);
      border: none;
      border-radius: 4px;
      padding: 0.4rem 0.8rem;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .filter-checkboxes select:hover {
      background: var(--bg-button-hover);
    }

    /* ── FOLDER FILTER STYLES ── */
    .folder-filter {
      margin-left: 1rem;
      background: var(--bg-button);
      color: var(--text-primary);
      border: none;
      border-radius: 4px;
      padding: 0.4rem 0.8rem;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .folder-filter:hover {
      background: var(--bg-button-hover);
    }

    /* Card animations */
    .entry-card.new-insert {
      opacity: 0;
      transform: scale(0.8);
      animation: popIn 0.3s ease-out forwards;
    }

    @keyframes popIn {
      0% {
        opacity: 0;
        transform: scale(0.8);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Add these styles after the existing styles */
    .twitch-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: var(--bg-overlay);
      z-index: 10000;
      display: none;
      padding: 2rem;
      box-sizing: border-box;
      overflow: hidden;
    }
    .twitch-overlay.show {
      display: flex;
      justify-content: center;
    }
    .twitch-sort-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-top: 2rem;
      overflow-y: auto;
      height: calc(100vh - 6rem);
      padding-right: 0.5rem;
    }
    .twitch-sort-list::-webkit-scrollbar {
      width: 6px;
    }
    .twitch-sort-list::-webkit-scrollbar-thumb {
      background: rgba(200, 200, 200, 0.3);
      border-radius: 3px;
    }
    .twitch-sort-list .twitch-icon-wrapper {
      position: relative;
    }
    .twitch-sort-list .twitch-icon-item {
      width: 50px;
      height: 50px;
      position: relative;
      cursor: grab;
    }
    .twitch-sort-list .twitch-icon-item.dragging {
      cursor: grabbing;
      opacity: 0.5;
    }
    .twitch-sort-list .twitch-icon-item img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid var(--text-primary);
      transition: border-color 0.2s ease, transform 0.2s ease;
      object-fit: cover;
      pointer-events: none;
    }
    .twitch-sort-list .twitch-icon-item.live img {
      border-color: #ff0000;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    .twitch-sort-list .twitch-icon-item.drop-target img {
      transform: scale(1.1);
      border-color: var(--text-accent);
      box-shadow: 0 0 15px var(--text-accent);
    }
    .twitch-chat-container {
      width: 100%;
      height: 100%;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }
    .twitch-chat-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Add pop-in animation for Twitch icons */
    .twitch-icon-wrapper {
      opacity: 1; /* Changed from 0 to ensure visibility by default */
      transform: none; /* Remove default transform */
    }
    .twitch-icon-wrapper.new-insert {
      animation: popIn 0.3s ease-out forwards;
    }
    
    @keyframes popIn {
      0% {
        opacity: 0;
        transform: scale(0.8);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>

  <!-- ── YouTube IFrame API ── -->
  <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>
  <!-- ── VERSION INDICATOR ── -->
  <div id="version-indicator"></div>

  <!-- ── LIVE BAR ── -->
  <div id="liveBar">
    <!-- Twitch avatars will appear here when live -->
  </div>

  <!-- ── SIDE MENU BACKDROP ── -->
  <div id="sideBackdrop" onclick="closeSideMenu()"></div>

  <!-- ── SIDE MENU (BURGER) ── -->
  <div id="sideMenu">
    <button class="close-arrow" onclick="closeSideMenu()">←</button>
    <h2>Menu</h2>
    <div class="side-controls">
      <input
        type="text"
        id="rssUrl"
        placeholder="Paste RSS Feed URLs (comma-separated)"
      />
      <select id="folderSelect">
        <option value="">Uncategorized</option>
      </select>
      <button onclick="addFeed()">+ Add Feed(s)</button>
      <input type="text" id="newFolderName" placeholder="New Folder Name" />
      <button onclick="addFolder()">+ Add Folder</button>

      <button onclick="showManageFeeds()">Manage Feeds</button>
      <button onclick="downloadLog()">Download Log</button>
      <button onclick="clearAllCache()" style="background: #cc0000;">
        Clear Everything
      </button>
      <button onclick="clearVideoCache()" style="background: #cc0000;">
        Clear Videos
      </button>
    </div>
  </div>

  <!-- ── HEADER with Main Tabs, Filters & Download Log ── -->
  <div class="header">
    <button class="burger-button" onclick="toggleSideMenu()">☰</button>
    <div class="main-tabs">
      <button id="tabRSS" class="active">RSS Feeds</button>
      <button id="tabTwitch">Twitch Queue</button>
    </div>
    <div class="filter-checkboxes" id="filterContainer">
      <label><input type="checkbox" id="filterYouTube" checked> YouTube</label>
      <label><input type="checkbox" id="filterPatreon" checked> Patreon</label>
      <label><input type="checkbox" id="filterAudio" checked> Hide Audio</label>
      <label><input type="checkbox" id="filterShort" checked> Hide Shorts</label>
    </div>
    <div class="filter-categories">
      <button id="btnNew">New</button>
      <button id="btnOld">Unwatched</button>
      <button id="btnWatched">Watched</button>
    </div>
    <select id="folderFilter" class="folder-filter">
      <option value="ALL">All Folders</option>
    </select>
  </div>

  <!-- ── RSS Tab Content ── -->
  <div id="rssContainer" class="tab-content active">
    <div id="mainContent">
      <div id="feedsContainer"></div>
    </div>
  </div>

  <!-- ── Twitch Queue Tab Content ── -->
  <div id="twitchContainer" class="tab-content">
    <h2>Twitch Queue</h2>
    <div id="twitchControls">
      <input type="text" id="twitchChannelInput" placeholder="Add Twitch Channel (e.g. ninja)" />
      <button onclick="addTwitchChannel()">+ Add Channel</button>
    </div>
    <div id="twitchList">
      <!-- Each .twitch-icon-item will be inserted here -->
    </div>
    <div id="twitchPlayerContainer">
      <!-- The Twitch embed iframe will go here -->
    </div>
    <div id="twitchStatus"></div>
  </div>

  <!-- ── TOAST (for "Patreon skipped") ── -->
  <div id="toast"></div>

  <!-- ── PLAYER OVERLAY (RSS) ── -->
  <div class="player-overlay" id="playerOverlay" onclick="overlayClick(event)">
    <div class="overlay-content">
      <div class="left-column">
        <button
          class="close-arrow"
          onclick="closeOverlay(); event.stopPropagation();"
        >
          ←
        </button>
        <div class="overlay-live-icons" id="overlayLiveIcons">
          <!-- Twitch avatars for live channels -->
        </div>
      </div>
      <div class="video-left">
        <div class="video-wrapper-container" id="videoContainer">
          <!-- YouTube <div id="yt-player"> created dynamically -->
        </div>
        <div class="video-info">
          <h2 id="videoTitle"></h2>
          <p id="videoDesc"></p>
          <button
            class="read-more-button"
            id="readMoreBtn"
            onclick="toggleDescription()"
          >
            Read More
          </button>
        </div>
      </div>
      <div class="video-right" id="queueList">
        <!-- Current video card + all future videos (now extends to bottom) -->
      </div>
    </div>
  </div>

  <!-- ── MANAGE FEEDS PANEL & BACKDROP ── -->
  <div id="manageBackdrop" onclick="closeManageFeeds()"></div>
  <div id="managePanel">
    <div class="manage-feeds-header">
      <h2>Manage Your Feeds</h2>
      <button onclick="closeManageFeeds()">×</button>
    </div>
    <div class="manage-feed-list" id="manageFeedList"></div>
  </div>

  <!-- ── TWITCH OVERLAY ── -->
  <div class="twitch-overlay" id="twitchOverlay" onclick="closeTwitchOverlay(event)">
    <div class="overlay-content">
      <div class="left-column">
        <button class="close-arrow" onclick="closeTwitchOverlay(); event.stopPropagation();">←</button>
        <div class="twitch-sort-list" id="twitchSortList">
          <!-- Twitch channel icons will be here -->
        </div>
      </div>
      <div class="video-left">
        <div class="video-wrapper-container" id="twitchPlayerWrapper">
          <!-- Twitch player will be created here -->
        </div>
        <div class="video-info">
          <h2 id="twitchChannelTitle"></h2>
        </div>
      </div>
      <div class="video-right">
        <div class="twitch-chat-container" id="twitchChatContainer">
          <!-- Twitch chat will be embedded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    /**************************************
     *  GLOBAL CONFIG
     **************************************/
    const APP_VERSION = 'v0.79';
    // Set version indicator
    document.title = `Custom RSS ${APP_VERSION}`;
    document.getElementById('version-indicator').textContent = APP_VERSION;

    /**************************************
     *  BASIC LOGGING
     **************************************/
    const logEntries = [];
    function addLog(message) {
      const timestamp = new Date().toISOString();
      logEntries.push(`[${timestamp}] ${message}`);
    }
    function downloadLog() {
      if (!logEntries.length) {
        alert("No log entries to download.");
        return;
      }
      const blob = new Blob([logEntries.join("\n")], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "rss-reader-log.txt";
      a.click();
      URL.revokeObjectURL(url);
    }

    /**************************************
     *  PERSISTENT STORES & INITIAL STATE
     **************************************/
    let videoHistory = JSON.parse(localStorage.getItem("rssVideoHistory")) || {};
    let videoStore = JSON.parse(localStorage.getItem("rssVideoStore")) || {};
    let watchedVideos = JSON.parse(localStorage.getItem("watchedVideos")) || [];
    let feeds = JSON.parse(localStorage.getItem("rssFeeds")) || [];
    let folders = JSON.parse(localStorage.getItem("rssFolders")) || [];

    let twitchChannels = JSON.parse(localStorage.getItem("twitchChannels")) || [];
    // twitchChannels: array of { name: "channel_name", priority: number, live: bool, avatar: string }

    let videoQueue = [];
    let currentVideoIndex = -1;
    let fullDescription = "";
    let showingFull = false;
    let currentCategory = "New"; // 'New','Unwatched','Watched'

    let ytPlayer = null;
    let wasFullscreen = false;

    function saveAll() {
      localStorage.setItem("rssFeeds", JSON.stringify(feeds));
      localStorage.setItem("rssFolders", JSON.stringify(folders));
      localStorage.setItem("rssVideoHistory", JSON.stringify(videoHistory));
      localStorage.setItem("rssVideoStore", JSON.stringify(videoStore));
      localStorage.setItem("watchedVideos", JSON.stringify(watchedVideos));
      localStorage.setItem("twitchChannels", JSON.stringify(twitchChannels));
      addLog("Saved all data to localStorage.");
    }

    /**************************************
     *  UI: Main-Tab Switching
     **************************************/
    const btnRSS = document.getElementById("tabRSS");
    const btnTwitch = document.getElementById("tabTwitch");
    const rssContainer = document.getElementById("rssContainer");
    const twitchContainer = document.getElementById("twitchContainer");

    btnRSS.addEventListener("click", () => {
      btnRSS.classList.add("active");
      btnTwitch.classList.remove("active");
      rssContainer.classList.add("active");
      twitchContainer.classList.remove("active");
    });
    btnTwitch.addEventListener("click", () => {
      btnTwitch.classList.add("active");
      btnRSS.classList.remove("active");
      twitchContainer.classList.add("active");
      rssContainer.classList.remove("active");
    });

    /**************************************
     *  LIVE BAR (Twitch Icons)
     **************************************/
    function updateLiveBar() {
      const bar = document.getElementById("liveBar");
      bar.innerHTML = "";

      // Sort channels by priority first
      const sortedChannels = [...twitchChannels].sort((a, b) => a.priority - b.priority);
      
      // Then display only live ones in that order
      for (const c of sortedChannels) {
        if (c.live) {
          const avatarUrl = c.avatar ||
            `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
          const icon = document.createElement("img");
          icon.src = avatarUrl;
          icon.title = c.name;
          icon.classList.add('live');
          icon.onclick = () => {
            openTwitchOverlay(c.name);
          };
          bar.appendChild(icon);
        }
      }
    }

    function updateOverlayLiveIcons() {
      const container = document.getElementById("overlayLiveIcons");
      container.innerHTML = "";

      // Sort channels by priority first
      const sortedChannels = [...twitchChannels].sort((a, b) => a.priority - b.priority);
      
      // Then display only live ones in that order
      for (const c of sortedChannels) {
        if (c.live) {
          const avatarUrl = c.avatar ||
            `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
          const icon = document.createElement("img");
          icon.src = avatarUrl;
          icon.title = c.name;
          icon.onclick = () => {
            openTwitchOverlay(c.name);
          };
          container.appendChild(icon);
        }
      }
    }

    // Update live bar and overlay-live icons every 30s
    setInterval(() => {
      updateLiveBar();
      updateOverlayLiveIcons();
    }, 30 * 1000);
    updateLiveBar();
    updateOverlayLiveIcons();

    /**************************************
     *  RSS FEEDS CODE (v0.37)
     **************************************/
    function clearAllCache() {
      if (!confirm("Clear ALL data including feeds and Twitch channels?")) return;
      localStorage.clear();
      feeds = [];
      folders = [];
      videoHistory = {};
      videoStore = {};
      watchedVideos = [];
      twitchChannels = [];
      document.getElementById("feedsContainer").innerHTML = "";
      document.getElementById("twitchPlayerContainer").innerHTML = "";
      document.getElementById("twitchStatus").textContent = "No channels in queue.";
      updateFolderDropdown();
      addLog("Cleared entire cache (feeds, video history, store, watched list, and Twitch channels).");
      initialRender();
      parseFeeds();
      renderTwitchList();
      renderTwitchSortList();
      updateLiveBar();
      updateOverlayLiveIcons();
    }
    function clearVideoCache() {
      if (!confirm("Clear only saved video info?")) return;
      videoHistory = {};
      videoStore = {};
      watchedVideos = [];
      localStorage.removeItem("rssVideoHistory");
      localStorage.removeItem("rssVideoStore");
      localStorage.removeItem("watchedVideos");
      addLog("Cleared video history, store, and watched list (but kept feed URLs).");
      initialRender();
      parseFeeds();
    }
    function toggleSideMenu() {
      document.getElementById("sideMenu").classList.toggle("open");
      document.getElementById("sideBackdrop").classList.toggle("show");
    }
    function closeSideMenu() {
      document.getElementById("sideMenu").classList.remove("open");
      document.getElementById("sideBackdrop").classList.remove("show");
    }
    function addFolder() {
      const name = document.getElementById("newFolderName").value.trim();
      if (name && !folders.includes(name)) {
        folders.push(name);
        updateFolderDropdown();
        saveAll();
        addLog(`Added new folder: "${name}".`);
        initialRender();
      }
      document.getElementById("newFolderName").value = "";
    }
    function updateFolderDropdown() {
      const select = document.getElementById("folderSelect");
      select.innerHTML = `<option value="">Uncategorized</option>`;
      folders.forEach((f) => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
    }
    function addFeed() {
      const raw = document.getElementById("rssUrl").value.trim();
      if (!raw) {
        alert("Please enter a valid RSS feed URL.");
        return;
      }
      const folder = document.getElementById("folderSelect").value;
      const parts = raw.split(",").map((s) => s.trim()).filter((s) => s);
      parts.forEach((url) => {
        if (feeds.some((f) => f.url === url)) {
          addLog(`Skipped adding duplicate feed: ${url}`);
          return;
        }
        feeds.push({
          url,
          folder,
          shortFilter: false,
          name: url, // Placeholder until we parse
        });
        addLog(`Added feed: ${url} (folder: "${folder}")`);
      });
      saveAll();
      initialRender();
      parseFeeds();
      document.getElementById("rssUrl").value = "";
      closeSideMenu();
    }
    function isLetterboxedThumbnail(url) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const topRow = ctx.getImageData(0, 0, canvas.width, 1).data;
          const bottomRow = ctx.getImageData(0, canvas.height - 1, canvas.width, 1).data;
          function isRowMostlyBlack(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i += 4) {
              sum += data[i] + data[i + 1] + data[i + 2];
            }
            const avg = sum / (data.length / 4);
            return avg < 20;
          }
          const topBlack = isRowMostlyBlack(topRow);
          const bottomBlack = isRowMostlyBlack(bottomRow);
          resolve(topBlack && bottomBlack);
        };
        img.onerror = () => {
          addLog(`Thumbnail load error: ${url}`);
          resolve(false);
        };
        img.src = url;
      });
    }

    // Show a brief toast message
    function showToast(msg) {
      const toast = document.getElementById("toast");
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toast._hideTimeout);
      toast._hideTimeout = setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }

    // INITIAL RENDER: show everything already in videoStore
    function initialRender() {
      updateFolderDropdown();
      updateFolderFilter(); // Add this line
      document.getElementById("feedsContainer").innerHTML = "";
      buildQueueFromStore();
      const watchedSet = new Set(watchedVideos);

      // Partition into categories:
      const newUnwatched = [];
      const oldUnwatched = [];
      const watchedList = [];
      const currentIDsSet = new Set();
      Object.entries(videoHistory).forEach(([feedUrl, arr]) => {
        arr.forEach((vid) => currentIDsSet.add(vid));
      });
      videoQueue.forEach((entry) => {
        const vid = entry.id;
        const inCurrent = currentIDsSet.has(vid);
        const isWatched = watchedSet.has(vid);
        if (isWatched) {
          watchedList.push(vid);
        } else if (inCurrent) {
          newUnwatched.push(vid);
        } else {
          oldUnwatched.push(vid);
        }
      });
      function sortByDateDesc(arr) {
        return arr.sort((a, b) => {
          const da = new Date(videoStore[a].date);
          const db = new Date(videoStore[b].date);
          return db - da;
        });
      }
      sortByDateDesc(newUnwatched);
      sortByDateDesc(oldUnwatched);
      sortByDateDesc(watchedList);

      const container = document.getElementById("feedsContainer");
      container.innerHTML = "";

      const categories = [
        { key: "New", title: `New (Unwatched) (${newUnwatched.length})`, ids: newUnwatched, css: "new-cat" },
        { key: "Unwatched", title: `Old Unwatched (${oldUnwatched.length})`, ids: oldUnwatched, css: "old-cat" },
        { key: "Watched", title: `Watched (${watchedList.length})`, ids: watchedList, css: "watched-cat" }
      ];

      categories.forEach(({ title, ids, css }) => {
        const block = document.createElement("div");
        block.className = `category-block ${css}`;
        block.dataset.category = css;
        block.innerHTML = `<h2>${title}</h2><div class="entry-grid"></div>`;
        container.appendChild(block);
        const grid = block.querySelector(".entry-grid");

        ids.forEach((vid) => {
          const data = videoStore[vid];
          const isWatched = watchedSet.has(vid);
          const div = document.createElement("div");
          div.className = "entry-card" + (isWatched ? " watching" : "");
          div.innerHTML = `
            <div class="channel-label">${data.authorName}</div>
            <div class="thumbnail-wrapper">
              <img src="${data.thumbnail}" alt="Thumbnail" />
            </div>
            <p title="${data.title}">${data.title}</p>
          `;
          div.onclick = () => expandVideoByID(vid);
          grid.appendChild(div);
        });
      });

      applyCategoryFilter();
      addLog(`Initial render: ${videoQueue.length} items from store.`);
    }

    // Rebuild videoQueue purely from current videoStore (used in initial render)
    function buildQueueFromStore() {
      videoQueue = [];
      const allIDs = Object.keys(videoStore);
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;
      const selectedFolder = document.getElementById("folderFilter").value;

      allIDs.forEach((vid) => {
        const data = videoStore[vid];
        const isYouTube = data.feedUrl.includes("youtube.com");
        const isPatreon = data.feedUrl.includes("patreon.com");
        const feed = feeds.find(f => f.url === data.feedUrl);
        const hideShortsForFeed = feed?.shortFilter;
        const feedFolder = feed?.folder || "";

        // Folder filter
        if (selectedFolder !== "ALL" && feedFolder !== selectedFolder) return;

        // 1) Source filter
        if (isYouTube && !chkYouTube) return;
        if (isPatreon && !chkPatreon) return;

        // 2) Audio filter
        if (data.entryType === "audio" && chkHideAudio) return;

        // 3) Shorts filter
        if (data.isShort && (chkHideShortsGlobal || hideShortsForFeed)) return;

        // 4) Video vs. other
        if (data.entryType !== "video") return;

        videoQueue.push({
          id: vid,
          title: data.title,
          embedUrl: data.embedUrl,
          link: data.link,
          desc: data.desc,
          feedUrl: data.feedUrl,
        });
      });

      videoQueue.sort((a, b) => {
        const da = new Date(videoStore[a.id].date);
        const db = new Date(videoStore[b.id].date);
        return db - da;
      });
    }

    // PARSE FEEDS: fetch each feed; on each NEW video, append to UI
    async function parseFeeds() {
      addLog("Starting feed parsing phase...");
      if (!feeds || feeds.length === 0) {
        addLog("No feeds configured. Skipping parse.");
        return;
      }
      addLog(`Found ${feeds.length} feeds to parse.`);
      const currentFeedSet = new Set();

      // First process all YouTube feeds in parallel batches
      const youtubeFeeds = feeds.filter(f => !f.url.includes("patreon.com"));
      addLog(`Processing ${youtubeFeeds.length} YouTube feeds...`);
      const batchSize = 5; // Reduced batch size to be gentler on the proxy
      const youtubeBatches = [];
      
      for (let i = 0; i < youtubeFeeds.length; i += batchSize) {
        youtubeBatches.push(youtubeFeeds.slice(i, i + batchSize));
      }

      // Process YouTube feeds efficiently
      for (const feedBatch of youtubeBatches) {
        addLog(`Processing batch of ${feedBatch.length} YouTube feeds...`);
        await Promise.all(feedBatch.map(async (feedObj) => {
          const feedUrl = feedObj.url;
          if (!videoHistory[feedUrl]) {
            videoHistory[feedUrl] = [];
          }

          try {
            // Try allorigins first
            let proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(feedUrl)}`;
            let response = await fetch(proxyUrl);
            
            // If allorigins fails, try codetabs
            if (!response.ok) {
              addLog(`AllOrigins failed for ${feedUrl}, trying CodeTabs...`);
              proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(feedUrl)}`;
              response = await fetch(proxyUrl);
              if (!response.ok) {
                throw new Error(`Both proxies failed for ${feedUrl}`);
              }
            }

            let xmlText;
            try {
              const data = await response.json();
              xmlText = data.contents;
            } catch {
              // If JSON parsing fails, assume direct XML response
              xmlText = await response.text();
            }

            if (!xmlText || xmlText.trim() === '') {
              throw new Error('Empty response from proxy');
            }

            const xml = new DOMParser().parseFromString(xmlText, "application/xml");
            if (xml.querySelector("parsererror")) {
              throw new Error('XML parsing error');
            }

            let feedTitle = feedObj.name || feedUrl;
            const titleEl = xml.querySelector("channel > title, entry > author > name");
            if (titleEl) feedTitle = titleEl.textContent.trim();
            feedObj.name = feedTitle;
            
            const entries = Array.from(xml.querySelectorAll("entry, item"));
            addLog(`Found ${entries.length} entries in feed "${feedTitle}"`);
            const newEntries = [];

            for (const entry of entries) {
              const title = entry.querySelector("title")?.textContent.trim() || "Untitled";
              let link = "";
              const linkEl = entry.querySelector("link");
              if (linkEl) {
                link = linkEl.getAttribute("href") || linkEl.textContent.trim();
              }

              let desc = "";
              const descEl = entry.querySelector("media\\:group yt\\:description") ||
                            entry.querySelector("content\\:encoded") ||
                            entry.querySelector("description");
              if (descEl) desc = descEl.textContent.trim();

              const entryAuthorEl = entry.querySelector("author > name");
              const entryAuthor = entryAuthorEl?.textContent.trim() || feedTitle;

              let dateText = "";
              const dateEl = entry.querySelector("published") ||
                            entry.querySelector("pubDate") ||
                            entry.querySelector("updated");
              const publishedDate = dateEl ? new Date(dateEl.textContent) : new Date();

              if (link.includes("youtube.com/watch?v=")) {
                const videoId = new URL(link).searchParams.get("v");
                currentFeedSet.add(videoId);

                if (!videoHistory[feedUrl].includes(videoId)) {
                  const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
                  const letterboxed = await isLetterboxedThumbnail(thumbnailUrl);
                  const isShort = !letterboxed;

                  newEntries.push({
                    id: videoId,
                    title,
                    embedUrl: `https://www.youtube.com/embed/${videoId}`,
                    link,
                    desc,
                    thumbnail: thumbnailUrl,
                    date: publishedDate.toISOString(),
                    feedName: feedTitle,
                    authorName: entryAuthor,
                    feedUrl,
                    isShort,
                    entryType: "video"
                  });
                }
              }
            }

            if (newEntries.length > 0) {
              addLog(`Adding ${newEntries.length} new entries from "${feedTitle}"`);
              
              // Sort new entries by date before adding
              newEntries.sort((a, b) => new Date(b.date) - new Date(a.date));
              
              // Add to history and store
              videoHistory[feedUrl].push(...newEntries.map(e => e.id));
              
              // Add each entry individually with a small delay for smooth animation
              for (const entry of newEntries) {
                videoStore[entry.id] = entry;
                appendVideoCard(entry.id);
                await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay between entries
              }
              
              saveAll();
            }

          } catch (err) {
            addLog(`FETCH ERROR for ${feedUrl}: ${err}`);
          }
        }));
      }

      // Process Patreon feeds similarly with delays for smooth animation
      const patreonFeeds = feeds.filter(f => f.url.includes("patreon.com"));
      addLog(`Processing ${patreonFeeds.length} Patreon feeds...`);
      
      for (const feedObj of patreonFeeds) {
        const feedUrl = feedObj.url;
        if (!videoHistory[feedUrl]) {
          videoHistory[feedUrl] = [];
        }

        let xml;
        try {
          const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(feedUrl)}`;
          addLog(`Fetching Patreon feed via CodeTabs proxy: ${feedUrl}`);
          const res = await fetch(proxyUrl);
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          const xmlText = await res.text();
          if (!xmlText || xmlText.trim() === '') {
            throw new Error('Empty response from proxy');
          }
          xml = new DOMParser().parseFromString(xmlText, "application/xml");
          if (xml.querySelector("parsererror")) {
            throw new Error('XML parsing error');
          }
        } catch (err) {
          addLog(`FETCH ERROR for ${feedUrl}: ${err}`);
          continue;
        }

        let feedTitle = feedObj.name || feedUrl;
        const titleEl = xml.querySelector("channel > title, entry > author > name");
        if (titleEl) feedTitle = titleEl.textContent.trim();
        feedObj.name = feedTitle;
        addLog(`Parsing feed "${feedTitle}" (${feedUrl})`);
        const entries = xml.querySelectorAll("entry, item");
        addLog(`Found ${entries.length} entries in Patreon feed "${feedTitle}"`);

        for (const entry of entries) {
          const title = entry.querySelector("title")?.textContent.trim() || "Untitled";
          let link = "";
          const linkEl = entry.querySelector("link");
          if (linkEl) {
            if (linkEl.getAttribute("href")) link = linkEl.getAttribute("href");
            else link = linkEl.textContent.trim();
          }
          let desc = "";
          const mediaDesc = entry.querySelector("media\\:group yt\\:description");
          const rssDesc = entry.querySelector("description");
          const contentEncoded = entry.querySelector("content\\:encoded");
          if (mediaDesc) desc = mediaDesc.textContent.trim();
          else if (contentEncoded) desc = contentEncoded.textContent.trim();
          else if (rssDesc) desc = rssDesc.textContent.trim();
          const entryAuthorEl = entry.querySelector("author > name");
          const entryAuthor = entryAuthorEl?.textContent.trim() || feedTitle;
          let dateText = "";
          if (entry.querySelector("published")) dateText = entry.querySelector("published").textContent;
          else if (entry.querySelector("pubDate")) dateText = entry.querySelector("pubDate").textContent;
          else if (entry.querySelector("updated")) dateText = entry.querySelector("updated").textContent;
          const publishedDate = dateText ? new Date(dateText) : new Date();

          const guidNode = entry.querySelector("guid");
          const uniqueId = feedUrl + "|" + (guidNode?.textContent.trim() || Math.random().toString(36).substr(2, 9));
          currentFeedSet.add(uniqueId);

          if (!videoHistory[feedUrl].includes(uniqueId)) {
            videoHistory[feedUrl].push(uniqueId);
            addLog(`New Patreon entry: ${title}`);

            let thumbUrl = "";
            let isAudio = false;
            let entryType = "video"; // default to video unless proven otherwise

            if (feedUrl.includes("patreon.com")) {
              // Check for audio in title or description
              const isAudioPost = /\[AUDIO\]|\(AUDIO\)|audio only|audio post/i.test(title) || 
                                /\[AUDIO\]|\(AUDIO\)|audio only|audio post/i.test(desc);
              
              if (isAudioPost) {
                entryType = "audio";
                addLog(`Patreon post tagged as audio: ${title}`);
              } else {
                entryType = "video";
                embedUrl = null; // will open externally
                addLog(`Patreon post treated as video: ${title}`);
              }
            } else {
              const enc = entry.querySelector("enclosure");
              if (enc) {
                const encType = enc.getAttribute("type") || "";
                const encUrl = enc.getAttribute("url") || "";
                if (encType.startsWith("audio")) {
                  entryType = "audio";
                } else if (encType.startsWith("video")) {
                  entryType = "video";
                  embedUrl = encUrl;
                }
              }
            }

            // Look for thumbnail
            const itunesImgNodes = entry.getElementsByTagNameNS(
              "http://www.itunes.com/dtds/podcast-1.0.dtd", "image"
            );
            if (itunesImgNodes.length > 0) {
              thumbUrl = itunesImgNodes[0].getAttribute("href") || "";
            } else {
              const mediaThumb = entry.querySelector("media\\:thumbnail");
              if (mediaThumb) {
                thumbUrl = mediaThumb.getAttribute("url") || "";
              }
            }

            const dataObj = {
              title,
              embedUrl: null,
              link,
              desc,
              thumbnail: thumbUrl,
              date: publishedDate.toISOString(),
              feedName: feedTitle,
              authorName: entryAuthor,
              feedUrl,
              isShort: false,
              entryType
            };
            videoStore[uniqueId] = dataObj;
            saveAll();

            appendVideoCard(uniqueId);
            await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay between entries
          }
        }
      }

      addLog("Finished parsing all feeds.");
      // After parsing, fetch thumbnails for any Patreon entries that need them
      fetchPatreonThumbnails();
    }

    // Add this function after parseFeeds but before appendVideoCard
    async function fetchPatreonThumbnails() {
      const entries = Object.entries(videoStore).filter(([id, data]) => 
        data.feedUrl.includes("patreon.com") && !data.thumbnail
      );

      if (entries.length === 0) return;
      addLog(`Fetching thumbnails for ${entries.length} Patreon entries`);

      const batchSize = 5;
      for (let i = 0; i < entries.length; i += batchSize) {
        const batch = entries.slice(i, i + batchSize);
        await Promise.all(batch.map(async ([id, data]) => {
          try {
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(data.link)}`;
            const res = await fetch(proxyUrl);
            const html = await res.text();
            const doc = new DOMParser().parseFromString(html, "text/html");
            
            // Look for og:image or twitter:image meta tags
            const ogImage = doc.querySelector('meta[property="og:image"]');
            const twitterImage = doc.querySelector('meta[name="twitter:image"]');
            const thumbnail = ogImage?.getAttribute('content') || twitterImage?.getAttribute('content');
            
            if (thumbnail) {
              videoStore[id].thumbnail = thumbnail;
              // Update the thumbnail in the UI
              const cards = document.querySelectorAll(`.entry-card img[src=""]`);
              cards.forEach(img => {
                const card = img.closest('.entry-card');
                const title = card?.querySelector('p')?.getAttribute('title');
                if (title === data.title) {
                  img.src = thumbnail;
                }
              });
              addLog(`Found thumbnail for Patreon post: ${data.title}`);
            }
          } catch (err) {
            addLog(`Failed to fetch Patreon thumbnail for ${data.title}: ${err}`);
          }
        }));
        
        // Save after each batch
        saveAll();
        
        // Small delay between batches to be nice to servers
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Append a single new video card to whichever category it belongs to,
    // and update the header count.
    function appendVideoCard(videoId) {
      const data = videoStore[videoId];
      const isYouTube = data.feedUrl.includes("youtube.com");
      const isPatreon = data.feedUrl.includes("patreon.com");
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;
      const selectedFolder = document.getElementById("folderFilter").value;
      const feed = feeds.find(f => f.url === data.feedUrl);
      const hideShortsForFeed = feed?.shortFilter;
      const feedFolder = feed?.folder || "";

      // Folder filter
      if (selectedFolder !== "ALL" && feedFolder !== selectedFolder) return;

      // 1) Source filter
      if (isYouTube && !chkYouTube) return;
      if (isPatreon && !chkPatreon) return;

      // 2) Audio filter
      if (data.entryType === "audio" && chkHideAudio) return;

      // 3) Shorts filter
      if (data.isShort && (chkHideShortsGlobal || hideShortsForFeed)) return;

      // 4) Must be a "video" entry
      if (data.entryType !== "video") return;

      // Create the card
      const div = document.createElement("div");
      const isWatched = watchedVideos.includes(videoId);
      div.className = `entry-card${isWatched ? " watching" : ""} new-insert`;
      div.innerHTML = `
        <div class="channel-label">${data.authorName}</div>
        <div class="thumbnail-wrapper">
          <img src="${data.thumbnail || ''}" alt="Thumbnail" />
        </div>
        <p title="${data.title}">${data.title}</p>
      `;
      div.onclick = () => expandVideoByID(videoId);
      div.dataset.date = new Date(data.date).getTime();

      // Find the correct category block
      const inCurrentFeed = videoHistory[data.feedUrl]?.includes(videoId);
      let categoryClass;
      if (isWatched) {
        categoryClass = "watched-cat";
      } else if (inCurrentFeed) {
        categoryClass = "new-cat";
      } else {
        categoryClass = "old-cat";
      }

      // Find or create the category-block
      let block = document.querySelector(`.category-block.${categoryClass}`);
      let grid;
      if (!block) {
        const container = document.getElementById("feedsContainer");
        block = document.createElement("div");
        block.className = `category-block ${categoryClass}`;
        block.dataset.category = categoryClass;
        const titleText = categoryClass === "new-cat"
          ? "New (Unwatched)"
          : categoryClass === "old-cat"
            ? "Old Unwatched"
            : "Watched";
        block.innerHTML = `<h2>${titleText} (1)</h2><div class="entry-grid"></div>`;
        
        // Insert block in correct order (New -> Unwatched -> Watched)
        const order = ["new-cat", "old-cat", "watched-cat"];
        const index = order.indexOf(categoryClass);
        let inserted = false;
        
        for (let i = 0; i < order.length; i++) {
          if (i === index) {
            container.appendChild(block);
            inserted = true;
            break;
          }
          const existing = document.querySelector(`.category-block.${order[i]}`);
          if (!existing && i > index) {
            container.appendChild(block);
            inserted = true;
            break;
          }
        }
        
        if (!inserted) {
          container.appendChild(block);
        }
        
        grid = block.querySelector(".entry-grid");
      } else {
        grid = block.querySelector(".entry-grid");
        const header = block.querySelector("h2");
        const match = header.textContent.match(/\((\d+)\)$/);
        let count = match ? parseInt(match[1], 10) : 0;
        count += 1;
        const titleText = header.textContent.replace(/\(\d+\)$/, "").trim();
        header.textContent = `${titleText} (${count})`;
      }

      // Find the correct position to insert the card based on date
      const existingCards = Array.from(grid.children);
      const insertIndex = existingCards.findIndex(card => {
        const cardDate = parseInt(card.dataset.date || "0");
        return new Date(data.date).getTime() > cardDate;
      });

      // Insert the card with animation
      if (insertIndex === -1) {
        grid.appendChild(div);
      } else {
        grid.insertBefore(div, existingCards[insertIndex]);
      }

      // Trigger animation if in view
      requestAnimationFrame(() => {
        const rect = div.getBoundingClientRect();
        const isInView = rect.top >= 0 && rect.bottom <= window.innerHeight;
        if (isInView) {
          div.classList.add('new-insert');
          div.addEventListener('animationend', () => {
            div.classList.remove('new-insert');
          }, { once: true });
        }
      });

      // Update category visibility based on current filter
      applyCategoryFilter();
    }

    // Expand video overlay and play
    function expandVideoByID(videoId) {
      const data = videoStore[videoId];
      
      // Mark as watched regardless of type
      if (!watchedVideos.includes(videoId)) {
        watchedVideos.push(videoId);
        saveAll();
        addLog(`Marked as watched: ${videoId}`);
      }

      // For Patreon, open in new tab instead of player
      if (data.feedUrl.includes("patreon.com")) {
        window.open(data.link, '_blank');
        return;
      }

      // For YouTube and others, continue with player
      buildQueueFromQueueState();
      currentVideoIndex = videoQueue.findIndex((v) => v.id === videoId);
      playCurrent();
    }

    // Build videoQueue from current filters and store (for overlay's "Up Next")
    function buildQueueFromQueueState() {
      videoQueue = [];
      const allIDs = Object.keys(videoStore);
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;
      const selectedFolder = document.getElementById("folderFilter").value;

      allIDs.forEach((vid) => {
        const data = videoStore[vid];
        const isYouTube = data.feedUrl.includes("youtube.com");
        const isPatreon = data.feedUrl.includes("patreon.com");
        const hideShortsForFeed = feeds.find(f => f.url === data.feedUrl)?.shortFilter;
        const feedFolder = feeds.find(f => f.url === data.feedUrl)?.folder || "";

        // Skip if folder doesn't match (unless ALL is selected)
        if (selectedFolder !== "ALL" && feedFolder !== selectedFolder) return;

        // Skip Patreon content in video player queue
        if (isPatreon) return;

        // 1) Source filter
        if (isYouTube && !chkYouTube) return;
        if (isPatreon && !chkPatreon) return;

        // 2) Audio filter
        if (data.entryType === "audio" && chkHideAudio) return;

        // 3) Shorts filter
        if (data.isShort && (chkHideShortsGlobal || hideShortsForFeed)) return;

        // 4) Must be a "video" entry
        if (data.entryType !== "video") return;

        videoQueue.push({
          id: vid,
          title: data.title,
          embedUrl: data.embedUrl,
          link: data.link,
          desc: data.desc,
          feedUrl: data.feedUrl,
        });
      });

      videoQueue.sort((a, b) => {
        const da = new Date(videoStore[a.id].date);
        const db = new Date(videoStore[b.id].date);
        return db - da;
      });
    }

    function playCurrent() {
      if (currentVideoIndex < 0 || currentVideoIndex >= videoQueue.length) {
        closeOverlay();
        return;
      }
      const entry = videoQueue[currentVideoIndex];
      openOverlay(entry);
    }

    function openOverlay({ id, title, embedUrl, desc }) {
      wasFullscreen = !!document.fullscreenElement;
      document.body.classList.add("no-scroll");
      document.getElementById("playerOverlay").classList.add("show");
      if (ytPlayer) {
        ytPlayer.destroy();
        ytPlayer = null;
      }
      const container = document.getElementById("videoContainer");
      container.innerHTML = "";
      const ytDiv = document.createElement("div");
      ytDiv.id = "yt-player";
      container.appendChild(ytDiv);
      const videoId = new URL(embedUrl).pathname.split("/").pop();
      ytPlayer = new YT.Player("yt-player", {
        videoId: videoId,
        playerVars: {
          autoplay: 1,
          rel: 0,
          playsinline: 1
        },
        events: {
          onReady: (event) => {
            if (wasFullscreen) {
              const overlayEl = document.getElementById("playerOverlay");
              if (overlayEl.requestFullscreen) {
                overlayEl.requestFullscreen().catch(() => {/*ignore*/});
              } else if (overlayEl.webkitRequestFullscreen) {
                overlayEl.webkitRequestFullscreen();
              }
            }
          },
          onStateChange: onPlayerStateChange
        }
      });
      document.getElementById("videoTitle").textContent = title;
      fullDescription = desc;
      showingFull = false;
      const descEl = document.getElementById("videoDesc");
      const btn = document.getElementById("readMoreBtn");
      if (fullDescription.length <= 300) {
        descEl.innerHTML = fullDescription.replace(/\n/g, "<br>");
        btn.style.display = "none";
      } else {
        descEl.innerHTML = fullDescription.slice(0, 300).replace(/\n/g, "<br>") + "...";
        btn.textContent = "Read More";
        btn.style.display = "inline";
      }
      renderQueueSidebar();
      updateOverlayLiveIcons();
      addLog(`Now playing YouTube video: ${id}`);
    }

    function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.ENDED) {
        addLog("YouTube video ended; advancing queue.");
        currentVideoIndex++;
        playCurrent();
      }
    }

    function toggleDescription() {
      const descEl = document.getElementById("videoDesc");
      const btn = document.getElementById("readMoreBtn");
      if (showingFull) {
        descEl.innerHTML = fullDescription.slice(0, 300).replace(/\n/g, "<br>") + "...";
        btn.textContent = "Read More";
      } else {
        descEl.innerHTML = fullDescription.replace(/\n/g, "<br>");
        btn.textContent = "Show Less";
      }
      showingFull = !showingFull;
    }

    function renderQueueSidebar() {
      const queueElem = document.getElementById("queueList");
      queueElem.innerHTML = "";
      const watchedSet = new Set(watchedVideos);

      // Current video card at top
      if (currentVideoIndex >= 0 && currentVideoIndex < videoQueue.length) {
        const currentId = videoQueue[currentVideoIndex].id;
        const data = videoStore[currentId];
        const card = document.createElement("div");
        card.className = "entry-card watching";
        card.innerHTML = `
          <div class="thumbnail-wrapper">
            <img src="${data.thumbnail}" alt="Thumbnail" />
          </div>
          <p title="${data.title}">${data.title}</p>
        `;
        queueElem.appendChild(card);
      }

      // All future videos
      videoQueue.forEach((entry, idx) => {
        if (idx <= currentVideoIndex) return;
        const data = videoStore[entry.id];
        const isWatched = watchedSet.has(entry.id);
        const div = document.createElement("div");
        div.className = "entry-card" + (isWatched ? " watching" : "");
        div.innerHTML = `
          <div class="thumbnail-wrapper">
            <img src="${data.thumbnail}" alt="Thumbnail" />
          </div>
          <p title="${data.title}">${data.title}</p>
        `;
        div.onclick = () => {
          currentVideoIndex = idx;
          playCurrent();
        };
        queueElem.appendChild(div);
      });
    }

    function closeOverlay() {
      document.getElementById("playerOverlay").classList.remove("show");
      document.body.classList.remove("no-scroll");
      if (ytPlayer) {
        ytPlayer.destroy();
        ytPlayer = null;
      }
      document.getElementById("videoContainer").innerHTML = "";
      currentVideoIndex = -1;
      addLog("Closed video overlay.");
    }

    function overlayClick(e) {
      // Only close if clicking directly on the overlay background
      if (e.target.classList.contains('player-overlay')) {
        closeOverlay();
      }
    }

    function showManageFeeds() {
      closeSideMenu();
      document.getElementById("manageBackdrop").classList.add("show");
      document.getElementById("managePanel").classList.add("show");
      renderManageFeedsList();
      document.body.classList.add("no-scroll");
      addLog("Opened Manage Feeds panel.");
    }

    function closeManageFeeds() {
      document.getElementById("manageBackdrop").classList.remove("show");
      document.getElementById("managePanel").classList.remove("show");
      document.body.classList.remove("no-scroll");
      addLog("Closed Manage Feeds panel.");
    }

    function renderManageFeedsList() {
      const container = document.getElementById("manageFeedList");
      container.innerHTML = "";
      if (feeds.length === 0) {
        const msg = document.createElement("p");
        msg.textContent = "No feeds added yet.";
        msg.style.color = "#ccc";
        container.appendChild(msg);
        return;
      }
      feeds.forEach((f, idx) => {
        const item = document.createElement("div");
        item.className = "manage-feed-item";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = f.name || f.url;
        nameInput.readOnly = true;
        const folderSelect = document.createElement("select");
        const uncOpt = document.createElement("option");
        uncOpt.value = "";
        uncOpt.textContent = "Uncategorized";
        folderSelect.appendChild(uncOpt);
        folders.forEach((folderName) => {
          const opt = document.createElement("option");
          opt.value = folderName;
          opt.textContent = folderName;
          folderSelect.appendChild(opt);
        });
        folderSelect.value = f.folder || "";
        folderSelect.onchange = () => {
          feeds[idx].folder = folderSelect.value;
          saveAll();
          addLog(`Changed folder for feed "${f.url}" to "${folderSelect.value}".`);
          initialRender();
        };
        const shortLabel = document.createElement("label");
        const shortCheckbox = document.createElement("input");
        shortCheckbox.type = "checkbox";
        shortCheckbox.checked = !!f.shortFilter;
        shortCheckbox.onchange = () => {
          feeds[idx].shortFilter = shortCheckbox.checked;
          saveAll();
          addLog(`Toggled shortFilter for "${f.url}" to ${shortCheckbox.checked}.`);
          initialRender();
        };
        shortLabel.appendChild(shortCheckbox);
        shortLabel.appendChild(document.createTextNode("Short Filter"));
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.onclick = () => {
          if (confirm("Delete this feed?")) {
            addLog(`Deleted feed: ${f.url}`);
            feeds.splice(idx, 1);
            saveAll();
            initialRender();
            parseFeeds();
            renderManageFeedsList();
          }
        };
        item.appendChild(nameInput);
        item.appendChild(folderSelect);
        item.appendChild(shortLabel);
        item.appendChild(delBtn);
        container.appendChild(item);
      });
    }

    function setCategory(category) {
      currentCategory = category;
      document.getElementById("btnNew").classList.toggle("active", category === "New");
      document.getElementById("btnOld").classList.toggle("active", category === "Unwatched");
      document.getElementById("btnWatched").classList.toggle("active", category === "Watched");
      // Re-filter displayed blocks
      applyCategoryFilter();
      addLog(`Switched category filter to "${category}".`);
    }

    function applyCategoryFilter() {
      document.querySelectorAll(".category-block").forEach((block) => {
        if (
          block.classList.contains("new-cat") &&
          currentCategory !== "New"
        ) {
          block.style.display = "none";
        } else if (
          block.classList.contains("old-cat") &&
          currentCategory !== "Unwatched"
        ) {
          block.style.display = "none";
        } else if (
          block.classList.contains("watched-cat") &&
          currentCategory !== "Watched"
        ) {
          block.style.display = "none";
        } else {
          block.style.display = "";
        }
      });
    }

    document.getElementById("btnNew").addEventListener("click", () => setCategory("New"));
    document.getElementById("btnOld").addEventListener("click", () => setCategory("Unwatched"));
    document.getElementById("btnWatched").addEventListener("click", () => setCategory("Watched"));
    document.getElementById("filterYouTube").addEventListener("change", () => {
      addLog(`Toggled YouTube filter: ${document.getElementById("filterYouTube").checked}`);
      initialRender();
    });
    document.getElementById("filterPatreon").addEventListener("change", () => {
      addLog(`Toggled Patreon filter: ${document.getElementById("filterPatreon").checked}`);
      initialRender();
    });
    document.getElementById("filterAudio").addEventListener("change", () => {
      addLog(`Toggled Hide Audio: ${document.getElementById("filterAudio").checked}`);
      initialRender();
    });
    document.getElementById("filterShort").addEventListener("change", () => {
      addLog(`Toggled Hide Shorts: ${document.getElementById("filterShort").checked}`);
      initialRender();
    });

    updateFolderDropdown();
    setCategory("New");
    // Initial load:
    initialRender();
    // Then parse feeds to discover any new items:
    parseFeeds();
    // Re-parse every 5 minutes:
    setInterval(parseFeeds, 5 * 60 * 1000);

    /**************************************
     *  TWITCH QUEUE CODE (updated)
     **************************************/
    let twitchInterval = null;
    let currentTwitchChannel = null;
    let isDragging = false; // flag to block click when dragging

    function saveTwitch() {
      localStorage.setItem("twitchChannels", JSON.stringify(twitchChannels));
    }

    function moveChannel(fromIdx, toIdx) {
      // Swap channels
      const temp = twitchChannels[fromIdx];
      twitchChannels[fromIdx] = twitchChannels[toIdx];
      twitchChannels[toIdx] = temp;

      // Update priorities
      twitchChannels.forEach((channel, idx) => {
        channel.priority = idx + 1;
      });

      // Save and refresh all UI elements
      saveTwitch();
      renderTwitchSortList();
      renderTwitchList();
      updateLiveBar();
      updateOverlayLiveIcons();
    }

    function updateChannelIcons(channelName, avatar, isLive) {
      addLog(`Updating icons for ${channelName}: avatar=${avatar ? 'yes' : 'no'}, live=${isLive}`);
      
      // Update in main list
      const mainIcon = document.querySelector(`#twitchList .twitch-icon-item[data-channel="${channelName}"] img`);
      if (mainIcon && avatar) {
        addLog(`Updating main list icon for ${channelName}`);
        mainIcon.src = avatar;
      } else if (!mainIcon) {
        addLog(`Could not find main list icon element for ${channelName}`);
      }
      
      // Update in sort list
      const sortIcon = document.querySelector(`#twitchSortList .twitch-icon-item[data-channel="${channelName}"] img`);
      if (sortIcon && avatar) {
        addLog(`Updating sort list icon for ${channelName}`);
        sortIcon.src = avatar;
      } else if (!sortIcon) {
        addLog(`Could not find sort list icon element for ${channelName}`);
      }

      // Update live status
      const icons = document.querySelectorAll(`.twitch-icon-item[data-channel="${channelName}"]`);
      if (icons.length > 0) {
        addLog(`Found ${icons.length} icon elements to update live status for ${channelName}`);
        icons.forEach(icon => {
          if (isLive) {
            icon.classList.add('live');
          } else {
            icon.classList.remove('live');
          }
        });
      } else {
        addLog(`No icon elements found for ${channelName}`);
      }
    }

    async function renderTwitchListWithAnimation(newChannel = null) {
      const list = document.getElementById("twitchList");
      
      // Sort by priority
      twitchChannels.sort((a, b) => a.priority - b.priority);

      // If adding a new channel, just append it with animation
      if (newChannel) {
        const wrapper = createTwitchIconElement(newChannel, twitchChannels.length - 1);
        // Add new-insert class after a brief delay to ensure proper animation
        requestAnimationFrame(() => {
          wrapper.classList.add('new-insert');
        });
        list.appendChild(wrapper);
        return;
      }

      // Otherwise, render the full list
      list.innerHTML = "";
      for (const [idx, channel] of twitchChannels.entries()) {
        const wrapper = createTwitchIconElement(channel, idx);
        list.appendChild(wrapper);
      }
    }

    // Update the initialization code to ensure the list is rendered on page load
    // Add this right before the startTwitchPolling() call
    document.addEventListener('DOMContentLoaded', () => {
      renderTwitchList();
      startTwitchPolling();
    });

    // Remove the old startTwitchPolling() call and replace with this
    function initializeTwitch() {
      // Render the initial list first
      renderTwitchList();
      startTwitchPolling();
    }

    // Update the INITIALIZE section
    // INITIALIZE
    document.getElementById("twitchControls").addEventListener("click", (e) => {
      if (e.target.tagName === "BUTTON") addTwitchChannel();
    });
    initializeTwitch();

    async function addTwitchChannel() {
      const input = document.getElementById("twitchChannelInput");
      const rawInput = input.value.trim().toLowerCase();
      if (!rawInput) return;

      // Split by commas and clean each name
      const channelNames = rawInput.split(',').map(name => name.trim()).filter(name => name);
      
      // Add each channel
      for (const name of channelNames) {
        if (twitchChannels.some((c) => c.name === name)) {
          addLog(`Skipped duplicate channel: ${name}`);
          continue;
        }

        const maxPrio = twitchChannels.reduce((max, c) => Math.max(max, c.priority), 0);
        // Add channel immediately with default icon
        const channel = { 
          name, 
          priority: maxPrio + 1, 
          live: false, 
          avatar: null,
          needsIconRefresh: true, // Flag for channels that need icon refresh
          iconRetryCount: 0 // Track number of retry attempts
        };
        twitchChannels.push(channel);
        
        // Save and render immediately with default icon
        saveTwitch();
        await renderTwitchListWithAnimation(channel);
        
        // Then try to get the channel status and avatar
        try {
          const { live, avatar } = await checkTwitchTracker(name);
          const index = twitchChannels.findIndex(c => c.name === name);
          if (index !== -1) {
            twitchChannels[index].live = live;
            if (avatar) {
              twitchChannels[index].avatar = avatar;
              twitchChannels[index].needsIconRefresh = false;
              twitchChannels[index].iconRetryCount = 0;
            } else {
              // If no avatar found, increment retry count
              twitchChannels[index].iconRetryCount++;
              addLog(`No avatar found for ${name}, retry count: ${twitchChannels[index].iconRetryCount}`);
            }
            addLog(`Updated Twitch channel: ${name} (live: ${live}, avatar: ${avatar ? 'found' : 'not found'})`);
            // Re-render just this channel's icons with the new avatar
            updateChannelIcons(name, avatar, live);
          }
        } catch (err) {
          addLog(`Error fetching status for ${name}: ${err}`);
          const index = twitchChannels.findIndex(c => c.name === name);
          if (index !== -1) {
            twitchChannels[index].iconRetryCount++;
            addLog(`Failed to fetch status for ${name}, retry count: ${twitchChannels[index].iconRetryCount}`);
          }
        }
      }

      input.value = "";
      updateLiveBar();
      updateOverlayLiveIcons();
    }

    function createTwitchIconElement(channel, idx) {
      const wrapper = document.createElement("div");
      wrapper.className = "twitch-icon-wrapper";

      // Channel icon
      const iconDiv = document.createElement("div");
      iconDiv.className = "twitch-icon-item" + (channel.live ? " live" : "");
      iconDiv.draggable = true;
      iconDiv.dataset.index = idx;
      iconDiv.dataset.channel = channel.name;
      
      const img = document.createElement("img");
      img.src = channel.avatar || 
        `https://static-cdn.jtvnw.net/jtv_user_pictures/${channel.name}-profile_image-70x70.png`;
      img.alt = channel.name;
      img.title = channel.name;
      
      iconDiv.appendChild(img);
      wrapper.appendChild(iconDiv);

      // Drag and drop handlers
      iconDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', idx.toString());
        iconDiv.classList.add('dragging');
      });

      iconDiv.addEventListener('dragend', (e) => {
        iconDiv.classList.remove('dragging');
        document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        updateLiveBar();
        updateOverlayLiveIcons();
      });

      iconDiv.addEventListener('dragenter', (e) => {
        e.preventDefault();
        if (!iconDiv.classList.contains('dragging')) {
          iconDiv.classList.add('drop-target');
        }
      });

      iconDiv.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      iconDiv.addEventListener('dragleave', (e) => {
        iconDiv.classList.remove('drop-target');
      });

      iconDiv.addEventListener('drop', (e) => {
        e.preventDefault();
        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
        const toIdx = parseInt(iconDiv.dataset.index);
        
        if (fromIdx !== toIdx) {
          moveChannel(fromIdx, toIdx);
        }
        
        iconDiv.classList.remove('drop-target');
      });

      // Click handler for playing channel
      iconDiv.addEventListener('click', () => {
        openTwitchOverlay(channel.name);
      });

      return wrapper;
    }

    // Add keypress handler for Twitch channel input
    document.getElementById("twitchChannelInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        addTwitchChannel();
      }
    });

    function removeTwitchChannel(idx) {
      twitchChannels.splice(idx, 1);
      saveTwitch();
      renderTwitchListWithAnimation();
      renderTwitchSortList();
      updateLiveBar();
    }

    function normalizePriorities() {
      twitchChannels.sort((a, b) => a.priority - b.priority);
      twitchChannels.forEach((c, i) => c.priority = i + 1);
      saveTwitch();
    }

    async function checkTwitchTracker(channel) {
      // Fetch via AllOrigins to avoid CORS
      try {
        addLog(`Fetching status for ${channel} via TwitchTracker...`);
        const proxyUrl = `https://api.allorigins.win/raw?url=https://twitchtracker.com/${channel}`;
        const res = await fetch(proxyUrl);
        if (!res.ok) {
          addLog(`HTTP error ${res.status} for ${channel}`);
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const html = await res.text();
        if (!html || html.trim() === '') {
          addLog(`Empty response for ${channel}`);
          throw new Error('Empty response from proxy');
        }
        const doc = new DOMParser().parseFromString(html, "text/html");

        // 1) "LIVE" check
        const badge = doc.querySelector(".live-indicator");
        const isLive = !!badge;

        // 2) Avatar check (profile image in #app-logo img)
        const logoImg = doc.querySelector("#app-logo img");
        const avatarUrl = logoImg ? logoImg.src : null;
        
        addLog(`Status check for ${channel}: live=${isLive}, avatar=${avatarUrl ? 'found' : 'not found'}`);
        return { live: isLive, avatar: avatarUrl };
      } catch (err) {
        addLog(`TwitchTracker error for ${channel}: ${err.message}`);
        return { live: false, avatar: null };
      }
    }

    async function checkTwitchAndPlay() {
      if (!twitchChannels.length) {
        document.getElementById("twitchPlayerContainer").innerHTML = "";
        document.getElementById("twitchStatus").textContent = "No channels in queue.";
        updateLiveBar();
        return;
      }

      addLog(`Checking status for ${twitchChannels.length} channels...`);

      // Sort channels by priority before checking status
      const sortedChannels = [...twitchChannels].sort((a, b) => a.priority - b.priority);
      
      const statuses = await Promise.all(
        sortedChannels.map((c) => checkTwitchTracker(c.name))
      );

      // Merge statuses back into channels while maintaining priority order
      let updatedCount = 0;
      statuses.forEach((st, i) => {
        const channel = sortedChannels[i];
        const originalIndex = twitchChannels.findIndex(c => c.name === channel.name);
        if (originalIndex !== -1) {
          const needsUpdate = twitchChannels[originalIndex].needsIconRefresh || 
                            twitchChannels[originalIndex].live !== st.live ||
                            (!twitchChannels[originalIndex].avatar && st.avatar);
          
          if (needsUpdate) {
            addLog(`Updating channel ${channel.name}: live=${st.live}, avatar=${st.avatar ? 'yes' : 'no'}`);
            twitchChannels[originalIndex].live = st.live;
            if (st.avatar) {
              twitchChannels[originalIndex].avatar = st.avatar;
              twitchChannels[originalIndex].needsIconRefresh = false;
            }
            updateChannelIcons(channel.name, st.avatar, st.live);
            updatedCount++;
          }
        }
      });

      addLog(`Updated ${updatedCount} channels with new information`);
      saveTwitch();
      updateLiveBar();

      // Filter only live channels, maintaining priority order
      const liveList = sortedChannels.filter((c) => {
        const originalChannel = twitchChannels.find(tc => tc.name === c.name);
        return originalChannel && originalChannel.live;
      });

      addLog(`Found ${liveList.length} live channels`);

      if (!liveList.length) {
        document.getElementById("twitchPlayerContainer").innerHTML = "";
        document.getElementById("twitchStatus").textContent = "No one is live right now.";
        return;
      }

      const topLive = liveList[0].name; // highest-priority live channel
      if (currentTwitchChannel === topLive) {
        document.getElementById("twitchStatus").textContent = `Watching ${topLive}`;
        return;
      }
      currentTwitchChannel = topLive;
      playTwitchChannel(topLive);
    }

    function playTwitchChannel(channel) {
      const parentDomain = window.location.hostname;
      const embedUrl =
        `https://player.twitch.tv/` +
        `?channel=${encodeURIComponent(channel)}` +
        `&parent=${parentDomain}` +
        `&autoplay=true`;

      const container = document.getElementById("twitchPlayerContainer");
      container.innerHTML = `
        <iframe
          src="${embedUrl}"
          allowfullscreen="true"
          scrolling="no"
          height="100%"
          width="100%">
        </iframe>
      `;
      document.getElementById("twitchStatus").textContent = `Now watching: ${channel}`;
      addLog(`Switched to live Twitch channel: ${channel}`);
    }

    function startTwitchPolling() {
      checkTwitchAndPlay();
      twitchInterval = setInterval(checkTwitchAndPlay, 30 * 1000);
      addLog("Started TwitchTracker polling every 30s.");
    }

    /**************************************
     *  RENDER + DRAG-N-DROP LOGIC
     **************************************/
    function renderTwitchList() {
      const list = document.getElementById("twitchList");
      list.innerHTML = "";

      // Sort by priority
      twitchChannels.sort((a, b) => a.priority - b.priority);

      twitchChannels.forEach((channel, idx) => {
        const wrapper = document.createElement("div");
        wrapper.className = "twitch-icon-wrapper";

        // Channel icon
        const iconDiv = document.createElement("div");
        iconDiv.className = "twitch-icon-item" + (channel.live ? " live" : "");
        iconDiv.draggable = true;
        iconDiv.dataset.index = idx;
        
        const img = document.createElement("img");
        img.src = channel.avatar || 
          `https://static-cdn.jtvnw.net/jtv_user_pictures/${channel.name}-profile_image-70x70.png`;
        img.alt = channel.name;
        img.title = channel.name;
        
        iconDiv.appendChild(img);
        wrapper.appendChild(iconDiv);

        // Drag and drop handlers
        iconDiv.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', idx.toString());
          iconDiv.classList.add('dragging');
        });

        iconDiv.addEventListener('dragend', (e) => {
          iconDiv.classList.remove('dragging');
          // Remove any lingering drop target indicators
          document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
          // Update live bars after drag ends
          updateLiveBar();
          updateOverlayLiveIcons();
        });

        iconDiv.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (!iconDiv.classList.contains('dragging')) {
            iconDiv.classList.add('drop-target');
          }
        });

        iconDiv.addEventListener('dragover', (e) => {
          e.preventDefault();
        });

        iconDiv.addEventListener('dragleave', (e) => {
          iconDiv.classList.remove('drop-target');
        });

        iconDiv.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
          const toIdx = parseInt(iconDiv.dataset.index);
          
          if (fromIdx !== toIdx) {
            moveChannel(fromIdx, toIdx);
          }
          
          iconDiv.classList.remove('drop-target');
        });

        // Click handler for playing channel
        iconDiv.addEventListener('click', () => {
          openTwitchOverlay(channel.name);
        });

        list.appendChild(wrapper);
      });
    }

    // Function to update the folder filter dropdown
    function updateFolderFilter() {
      const select = document.getElementById("folderFilter");
      const currentValue = select.value || "ALL"; // Store current selection
      select.innerHTML = '<option value="ALL">All Folders</option>';
      folders.forEach((folder) => {
        const opt = document.createElement("option");
        opt.value = folder;
        opt.textContent = folder;
        select.appendChild(opt);
      });
      select.value = currentValue; // Restore selection
    }

    // Move the event listener outside of initialRender to prevent duplicates
    document.getElementById("folderFilter").addEventListener("change", () => {
      addLog(`Changed folder filter to: ${document.getElementById("folderFilter").value}`);
      buildQueueFromStore();
      const container = document.getElementById("feedsContainer");
      container.innerHTML = "";
      const watchedSet = new Set(watchedVideos);

      // Partition into categories:
      const newUnwatched = [];
      const oldUnwatched = [];
      const watchedList = [];
      const currentIDsSet = new Set();
      Object.entries(videoHistory).forEach(([feedUrl, arr]) => {
        arr.forEach((vid) => currentIDsSet.add(vid));
      });
      videoQueue.forEach((entry) => {
        const vid = entry.id;
        const inCurrent = currentIDsSet.has(vid);
        const isWatched = watchedSet.has(vid);
        if (isWatched) {
          watchedList.push(vid);
        } else if (inCurrent) {
          newUnwatched.push(vid);
        } else {
          oldUnwatched.push(vid);
        }
      });

      function sortByDateDesc(arr) {
        return arr.sort((a, b) => {
          const da = new Date(videoStore[a].date);
          const db = new Date(videoStore[b].date);
          return db - da;
        });
      }
      sortByDateDesc(newUnwatched);
      sortByDateDesc(oldUnwatched);
      sortByDateDesc(watchedList);

      const categories = [
        { key: "New", title: `New (Unwatched) (${newUnwatched.length})`, ids: newUnwatched, css: "new-cat" },
        { key: "Unwatched", title: `Old Unwatched (${oldUnwatched.length})`, ids: oldUnwatched, css: "old-cat" },
        { key: "Watched", title: `Watched (${watchedList.length})`, ids: watchedList, css: "watched-cat" }
      ];

      categories.forEach(({ title, ids, css }) => {
        const block = document.createElement("div");
        block.className = `category-block ${css}`;
        block.dataset.category = css;
        block.innerHTML = `<h2>${title}</h2><div class="entry-grid"></div>`;
        container.appendChild(block);
        const grid = block.querySelector(".entry-grid");

        ids.forEach((vid) => {
          const data = videoStore[vid];
          const isWatched = watchedSet.has(vid);
          const div = document.createElement("div");
          div.className = "entry-card" + (isWatched ? " watching" : "");
          div.innerHTML = `
            <div class="channel-label">${data.authorName}</div>
            <div class="thumbnail-wrapper">
              <img src="${data.thumbnail}" alt="Thumbnail" />
            </div>
            <p title="${data.title}">${data.title}</p>
          `;
          div.onclick = () => expandVideoByID(vid);
          grid.appendChild(div);
        });
      });

      applyCategoryFilter();
    });

    function openTwitchOverlay(channel) {
      // Close YouTube viewer if it's open
      closeOverlay();
      
      document.body.classList.add("no-scroll");
      document.getElementById("twitchOverlay").classList.add("show");
      
      // Update channel title
      document.getElementById("twitchChannelTitle").textContent = channel;
      
      // Create Twitch player
      const parentDomain = window.location.hostname;
      const playerEmbed = `https://player.twitch.tv/?channel=${channel}&parent=${parentDomain}&autoplay=true`;
      const chatEmbed = `https://www.twitch.tv/embed/${channel}/chat?parent=${parentDomain}&darkpopout`;
      
      document.getElementById("twitchPlayerWrapper").innerHTML = `
        <iframe
          src="${playerEmbed}"
          allowfullscreen="true"
          scrolling="no"
          height="100%"
          width="100%">
        </iframe>
      `;
      
      document.getElementById("twitchChatContainer").innerHTML = `
        <iframe
          src="${chatEmbed}"
          height="100%"
          width="100%">
        </iframe>
      `;

      // Update all UI elements
      renderTwitchSortList();
      renderTwitchList();
      updateLiveBar();
    }

    function closeTwitchOverlay() {
      document.getElementById("twitchOverlay").classList.remove("show");
      document.body.classList.remove("no-scroll");
      document.getElementById("twitchPlayerWrapper").innerHTML = "";
      document.getElementById("twitchChatContainer").innerHTML = "";
    }

    function renderTwitchSortList() {
      const list = document.getElementById("twitchSortList");
      list.innerHTML = "";
      
      // Sort channels by priority
      const sortedChannels = [...twitchChannels].sort((a, b) => a.priority - b.priority);
      
      sortedChannels.forEach((channel, idx) => {
        const wrapper = document.createElement("div");
        wrapper.className = "twitch-icon-wrapper";
        
        const iconDiv = document.createElement("div");
        iconDiv.className = "twitch-icon-item" + (channel.live ? " live" : "");
        iconDiv.draggable = true;
        iconDiv.dataset.index = idx;
        
        const img = document.createElement("img");
        img.src = channel.avatar || 
          `https://static-cdn.jtvnw.net/jtv_user_pictures/${channel.name}-profile_image-70x70.png`;
        img.alt = channel.name;
        img.title = channel.name;
        
        iconDiv.appendChild(img);
        wrapper.appendChild(iconDiv);
        
        // Drag and drop handlers
        iconDiv.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', idx.toString());
          iconDiv.classList.add('dragging');
        });
        
        iconDiv.addEventListener('dragend', (e) => {
          iconDiv.classList.remove('dragging');
          document.querySelectorAll('.drop-target').forEach(el => 
            el.classList.remove('drop-target')
          );
        });
        
        iconDiv.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (!iconDiv.classList.contains('dragging')) {
            iconDiv.classList.add('drop-target');
          }
        });
        
        iconDiv.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        
        iconDiv.addEventListener('dragleave', (e) => {
          iconDiv.classList.remove('drop-target');
        });
        
        iconDiv.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
          const toIdx = parseInt(iconDiv.dataset.index);
          
          if (fromIdx !== toIdx) {
            moveChannel(fromIdx, toIdx);
          }
          
          iconDiv.classList.remove('drop-target');
        });
        
        // Click handler
        iconDiv.addEventListener('click', () => {
          openTwitchOverlay(channel.name);
        });
        
        list.appendChild(wrapper);
      });
    }

    // Keep the existing moveChannel function as is since it works
    function moveChannel(fromIdx, toIdx) {
      // Swap channels
      const temp = twitchChannels[fromIdx];
      twitchChannels[fromIdx] = twitchChannels[toIdx];
      twitchChannels[toIdx] = temp;

      // Update priorities
      twitchChannels.forEach((channel, idx) => {
        channel.priority = idx + 1;
      });

      // Save and refresh both lists
      saveTwitch();
      renderTwitchSortList();
      renderTwitchList();
    }
  </script>
</body>
</html>
</html>