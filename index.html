<style>
  /* ── TWITCH QUEUE UI (updated) ── */
  #twitchContainer {
    padding: 1rem;
  }
  #twitchControls {
    display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  #twitchControls input[type="text"] {
    padding: 0.5rem; border: none; border-radius: 4px;
    background: #330033; color: var(--text-primary); flex: 1;
  }
  #twitchControls button {
    background: var(--bg-button); color: var(--text-primary);
    border: none; border-radius: 4px; padding: 0.5rem 1rem;
    cursor: pointer; transition: background 0.2s ease;
  }
  #twitchControls button:hover {
    background: var(--bg-button-hover);
  }

  /* Draggable circle icons (with drag‐over highlight) */
  #twitchList {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 1rem;
  }
  .twitch-icon-item {
    cursor: grab;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid var(--text-primary);
    transition: transform 0.15s ease, outline 0.15s ease;
    position: relative;
  }
  .twitch-icon-item.drag‐active {
    opacity: 0.6;
    transform: scale(1.1);
    cursor: grabbing;
  }
  .twitch-icon-item.drag‐over {
    outline: 2px dashed var(--text-accent);
  }
  .twitch-icon-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    pointer-events: none;
    user-select: none;
  }

  #twitchPlayerContainer {
    margin-top: 1.5rem;
    width: 100%; max-width: 800px; aspect-ratio: 16/9;
    background: #000; border-radius: 8px; overflow: hidden;
    position: relative;
  }
  #twitchPlayerContainer iframe {
    width: 100%; height: 100%; border: none;
  }
  #twitchStatus {
    margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);
  }
</style>

<script>
  /**************************************
   *  TWITCH QUEUE CODE (updated)
   **************************************/
  let twitchChannels = JSON.parse(localStorage.getItem("twitchChannels")) || [];
  // twitchChannels: array of { name: "channel_name", priority: number, live: bool, avatar: string }

  let twitchInterval = null;
  let currentTwitchChannel = null;
  let isDragging = false; // flag to block click when dragging

  function saveTwitch() {
    localStorage.setItem("twitchChannels", JSON.stringify(twitchChannels));
  }

  function addTwitchChannel() {
    const input = document.getElementById("twitchChannelInput");
    const name = input.value.trim().toLowerCase();
    if (!name) return;
    if (twitchChannels.some((c) => c.name === name)) {
      alert("Channel already in queue.");
      return;
    }
    const maxPrio = twitchChannels.reduce((max, c) => Math.max(max, c.priority), 0);
    twitchChannels.push({ name, priority: maxPrio + 1, live: false, avatar: null });
    saveTwitch();
    input.value = "";
    renderTwitchList();
  }

  function removeTwitchChannel(idx) {
    twitchChannels.splice(idx, 1);
    saveTwitch();
    renderTwitchList();
  }

  function normalizePriorities() {
    twitchChannels.sort((a, b) => a.priority - b.priority);
    twitchChannels.forEach((c, i) => c.priority = i + 1);
    saveTwitch();
  }

  async function checkTwitchTracker(channel) {
    // Fetch via AllOrigins to avoid CORS
    try {
      const proxyUrl = `https://api.allorigins.win/raw?url=https://twitchtracker.com/${channel}`;
      const res = await fetch(proxyUrl);
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, "text/html");

      // 1) “LIVE” check
      const badge = doc.querySelector(".live-indicator");
      const isLive = !!badge;

      // 2) Avatar check (profile image in #app-logo img)
      const logoImg = doc.querySelector("#app-logo img");
      const avatarUrl = logoImg ? logoImg.src : null;

      return { live: isLive, avatar: avatarUrl };
    } catch (err) {
      console.warn(`TwitchTracker fetch error for ${channel}:`, err);
      return { live: false, avatar: null };
    }
  }

  async function checkTwitchAndPlay() {
    if (!twitchChannels.length) {
      document.getElementById("twitchPlayerContainer").innerHTML = "";
      document.getElementById("twitchStatus").textContent = "No channels in queue.";
      updateLiveBar();
      return;
    }
    const statuses = await Promise.all(
      twitchChannels.map((c) => checkTwitchTracker(c.name))
    );
    // Merge statuses back into channels
    statuses.forEach((st, i) => {
      twitchChannels[i].live = st.live;
      if (st.avatar) twitchChannels[i].avatar = st.avatar;
    });
    updateLiveBar();

    // Filter only live channels, sort by priority
    const liveList = twitchChannels
      .filter((c) => c.live)
      .sort((a, b) => a.priority - b.priority);
    if (!liveList.length) {
      document.getElementById("twitchPlayerContainer").innerHTML = "";
      document.getElementById("twitchStatus").textContent = "No one is live right now.";
      return;
    }
    const topLive = liveList[0].name; // highest‐priority
    if (currentTwitchChannel === topLive) {
      document.getElementById("twitchStatus").textContent = `Watching ${topLive}`;
      return;
    }
    currentTwitchChannel = topLive;
    playTwitchChannel(topLive);
  }

  function playTwitchChannel(channel) {
    // GitHub Pages is whitelisted, so use window.location.hostname
    const parentDomain = window.location.hostname;
    const embedUrl =
      `https://player.twitch.tv/` +
      `?channel=${encodeURIComponent(channel)}` +
      `&parent=${parentDomain}` +
      `&autoplay=true`;

    const container = document.getElementById("twitchPlayerContainer");
    container.innerHTML = `
      <iframe
        src="${embedUrl}"
        allowfullscreen="true"
        scrolling="no"
        height="100%"
        width="100%">
      </iframe>
    `;
    document.getElementById("twitchStatus").textContent = `Now watching: ${channel}`;
  }

  function startTwitchPolling() {
    checkTwitchAndPlay();
    twitchInterval = setInterval(checkTwitchAndPlay, 30 * 1000);
  }

  /**************************************
   *  RENDER + DRAG‐N‐DROP LOGIC
   **************************************/
  function renderTwitchList() {
    const list = document.getElementById("twitchList");
    list.innerHTML = "";
    // Sort by priority:
    twitchChannels.sort((a, b) => a.priority - b.priority);

    twitchChannels.forEach((c, idx) => {
      const item = document.createElement("div");
      item.className = "twitch-icon-item";
      item.setAttribute("data-index", idx);

      // Avatar image:
      const img = document.createElement("img");
      img.src = c.avatar ||
        `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
      img.alt = c.name;
      item.appendChild(img);

      // CLICK: open channel if not dragging
      item.addEventListener("click", (e) => {
        if (!isDragging) {
          playTwitchChannel(c.name);
        }
      });

      // MOUSE‐DOWN: start a drag
      item.addEventListener("mousedown", (e) => onDragStart(e, idx));

      list.appendChild(item);
    });
  }

  let dragInfo = null;
  function onDragStart(e, sourceIdx) {
    e.preventDefault();
    isDragging = true;

    const original = e.currentTarget;
    const rect = original.getBoundingClientRect();

    // Clone it:
    const clone = original.cloneNode(true);
    clone.style.position = "absolute";
    clone.style.left = rect.left + "px";
    clone.style.top = rect.top + "px";
    clone.style.width = rect.width + "px";
    clone.style.height = rect.height + "px";
    clone.style.pointerEvents = "none";
    clone.style.zIndex = 20000;
    clone.classList.add("drag‐active");
    document.body.appendChild(clone);

    dragInfo = {
      sourceIdx,
      cloneElem: clone,
      offsetX: e.clientX - rect.left,
      offsetY: e.clientY - rect.top
    };

    document.addEventListener("mousemove", onDragging);
    document.addEventListener("mouseup", onDrop);
  }

  function onDragging(e) {
    if (!dragInfo) return;
    dragInfo.cloneElem.style.left = e.clientX - dragInfo.offsetX + "px";
    dragInfo.cloneElem.style.top = e.clientY - dragInfo.offsetY + "px";

    // Highlight potential drop target
    document.querySelectorAll(".twitch-icon-item").forEach((el) => {
      el.classList.remove("drag‐over");
    });
    const under = document.elementFromPoint(e.clientX, e.clientY);
    if (under) {
      const target = under.closest(".twitch-icon-item");
      if (target && target.getAttribute("data-index") !== null) {
        target.classList.add("drag‐over");
      }
    }
  }

  function onDrop(e) {
    if (!dragInfo) return;
    document.removeEventListener("mousemove", onDragging);
    document.removeEventListener("mouseup", onDrop);

    // Determine drop target
    const under = document.elementFromPoint(e.clientX, e.clientY);
    let targetIdx = null;
    if (under) {
      const target = under.closest(".twitch-icon-item");
      if (target && target.getAttribute("data-index") !== null) {
        targetIdx = parseInt(target.getAttribute("data-index"), 10);
        target.classList.remove("drag‐over");
      }
    }

    // Remove the clone
    document.body.removeChild(dragInfo.cloneElem);
    dragInfo.cloneElem = null;

    const sourceIdx = dragInfo.sourceIdx;
    dragInfo = null;

    // If a valid drop index and it’s different, reorder:
    if (targetIdx !== null && targetIdx !== sourceIdx) {
      const [moved] = twitchChannels.splice(sourceIdx, 1);
      twitchChannels.splice(targetIdx, 0, moved);
      normalizePriorities();
    }

    renderTwitchList();
    // Wait a brief moment before re‐enabling clicks
    setTimeout(() => {
      isDragging = false;
    }, 50);
  }

  // INITIALIZE
  document.getElementById("twitchControls").addEventListener("click", (e) => {
    if (e.target.tagName === "BUTTON") addTwitchChannel();
  });
  renderTwitchList();
  startTwitchPolling();
</script>
