<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom RSS & Twitch v0.43</title>
  <style>
    /* ── COLOR VARIABLES FOR PURPLE GRADIENT THEME ── */
    :root {
      --bg-page: linear-gradient(135deg, #2e003e, #5e008e);
      --bg-card: #3b003b;
      --bg-card-hover: #5e005e;
      --bg-overlay: linear-gradient(135deg, rgba(46, 0, 62, 0.95), rgba(94, 0, 142, 0.95));
      --bg-info: #4a004a;
      --bg-button: #6a0dad;
      --bg-button-hover: #8f13d9;
      --bg-home-button: #5c005c;
      --bg-home-button-hover: #7e007e;
      --bg-side-menu: #2a002a;
      --bg-backdrop: rgba(0, 0, 0, 0.5);
      --text-primary: #f0e4ff;
      --text-secondary: #d1b3ff;
      --text-accent: #c18cff;
      --overlay-text-bg: rgba(60, 0, 60, 0.9);
      --toast-bg: rgba(0, 0, 0, 0.8);
      --toast-text: #f0e4ff;
      --tab-active-bg: #440044;
      --tab-inactive-bg: #2a002a;
      --live-bar-bg: rgba(0,0,0,0.6);
    }

    /* ── GLOBAL BOX-SIZING & FULL-HEIGHT SETUP ── */
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; padding: 0; }

    /* ── BODY & PAGE BACKGROUND ── */
    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg-page);
      background-attachment: fixed;
      background-size: cover;
      color: var(--text-primary);
      margin: 0; padding: 0; overflow-x: hidden;
    }
    h1 { margin: 0; padding: 1rem; font-weight: 400; }

    /* ── LIVE BAR (always at top) ── */
    #liveBar {
      position: sticky; top: 0; z-index: 2000;
      background: var(--live-bar-bg);
      padding: 0.25rem 1rem;
      display: flex; align-items: center; gap: 0.5rem;
      overflow-x: auto;
    }
    #liveBar img {
      width: 32px; height: 32px; border-radius: 50%;
      object-fit: cover; border: 1px solid var(--text-primary);
      cursor: pointer;
    }

    /* ── HEADER BAR ── */
    .header {
      display: flex; align-items: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.5rem 1rem; position: sticky;
      top: 32px; /* just below liveBar */
      z-index: 1000;
    }
    .version-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-right: 1rem;
    }
    .burger-button {
      font-size: 1.5rem; background: none;
      border: none; color: var(--text-primary);
      cursor: pointer; margin-right: 1rem;
    }
    .main-tabs {
      display: flex; gap: 0.5rem;
    }
    .main-tabs button {
      background: var(--tab-inactive-bg); color: var(--text-primary);
      border: none; border-radius: 4px 4px 0 0;
      padding: 0.5rem 1rem; cursor: pointer;
      font-size: 0.95rem; transition: background 0.2s ease;
    }
    .main-tabs button.active {
      background: var(--tab-active-bg);
    }
    .filter-checkboxes {
      display: flex; flex-wrap: wrap; gap: 1rem;
      margin-left: auto; align-items: center;
    }
    .filter-checkboxes label {
      display: flex; align-items: center;
      font-size: 0.9rem; cursor: pointer;
      color: var(--text-primary);
    }
    .filter-checkboxes label input {
      margin-right: 0.3rem;
      cursor: pointer;
    }
    .filter-categories {
      display: flex; gap: 0.5rem; align-items: center;
      margin-left: 1rem;
    }
    .filter-categories button {
      background: var(--bg-button); color: var(--text-primary);
      border: none; border-radius: 4px;
      padding: 0.5rem 1rem; cursor: pointer;
      font-size: 0.9rem; transition: background 0.2s ease;
    }
    .filter-categories button.active {
      background: var(--bg-home-button);
    }
    .filter-categories button:hover {
      background: var(--bg-button-hover);
    }
    .refresh-button {
      margin-left: 1rem;
      background: var(--bg-button); color: var(--text-primary);
      border: none; border-radius: 4px;
      padding: 0.4rem 0.8rem; cursor: pointer;
      font-size: 0.9rem; transition: background 0.2s ease;
    }
    .refresh-button:hover {
      background: var(--bg-button-hover);
    }

    /* ── SIDE MENU BACKDROP ── */
    #sideBackdrop {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-backdrop);
      z-index: 1400; display: none;
    }
    #sideBackdrop.show { display: block; }

    /* ── SIDE MENU (BURGER) ── */
    #sideMenu {
      position: fixed; top: 0; left: 0;
      width: 250px; height: 100vh;
      background: var(--bg-side-menu);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 1500; padding: 1rem;
      box-sizing: border-box;
      display: flex; flex-direction: column;
    }
    #sideMenu.open { transform: translateX(0); }

    .close-arrow {
      align-self: flex-start;
      background: none; border: none;
      color: var(--text-primary);
      font-size: 1.2rem; cursor: pointer;
      margin-bottom: 1rem;
    }

    #sideMenu h2 {
      margin: 0 0 1rem; color: var(--text-primary);
      font-size: 1.2rem;
    }
    .side-controls {
      flex: 1; display: flex; flex-direction: column;
    }
    .side-controls input,
    .side-controls select,
    .side-controls button,
    .side-controls label {
      width: 100%; margin-bottom: 0.75rem;
    }
    .side-controls input[type="text"],
    .side-controls select {
      background: #330033; color: var(--text-primary);
    }
    .side-controls button {
      background: var(--bg-button); color: var(--text-primary);
      padding: 0.5rem; border: none;
      border-radius: 4px; cursor: pointer;
      transition: background 0.2s ease;
    }
    .side-controls button:hover {
      background: var(--bg-button-hover);
    }
    .side-controls label {
      display: flex; align-items: center;
      color: var(--text-primary); cursor: pointer;
    }
    .side-controls label input {
      margin-right: 0.5rem; cursor: pointer;
    }

    /* ── Tabs’ content containers ── */
    .tab-content {
      display: none;
      padding-top: 1rem;
    }
    .tab-content.active {
      display: block;
    }

    /* ── PAGE CONTENT (RSS) ── */
    #rssContainer #mainContent { padding: 1rem; }
    .category-block { margin-bottom: 2rem; }
    .category-block h2 {
      margin: 0 0 0.5rem; font-size: 1.3rem;
      color: var(--text-primary);
    }
    .entry-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem; margin-top: 1rem;
    }
    .entry-card {
      background: var(--bg-card); border-radius: 12px;
      overflow: hidden; cursor: pointer;
      transition: background 0.2s ease;
      position: relative; display: flex;
      flex-direction: column; align-items: center;
    }
    .entry-card:hover { background: var(--bg-card-hover); }
    .thumbnail-wrapper {
      width: 100%; position: relative;
      padding-top: 56.25%; overflow: hidden;
      background: #000;
    }
    .thumbnail-wrapper img {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%; object-fit: cover;
    }
    .entry-card p {
      margin: 0.5rem; font-size: 0.95rem;
      color: var(--text-primary); text-overflow: ellipsis;
      overflow: hidden; white-space: nowrap;
      width: 100%; text-align: center; flex-shrink: 0;
    }
    .entry-card .channel-label {
      position: absolute;
      top: 4px; left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: var(--text-secondary);
      font-size: 0.75rem;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .entry-card.watching::after {
      content: "Watching"; position: absolute;
      top: 8px; left: 8px; background: rgba(60, 0, 60, 0.7);
      color: var(--text-primary); padding: 0.25rem 0.5rem;
      font-size: 0.8rem; border-radius: 4px;
    }
    .entry-card.watching {
      opacity: 0.6; pointer-events: none;
    }

    /* ── PLAYER OVERLAY (RSS) ── */
    .player-overlay {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-overlay);
      z-index: 10000; display: none;
      padding: 2rem; box-sizing: border-box;
      overflow: hidden;
    }
    .player-overlay.show {
      display: flex; justify-content: center;
    }
    body.no-scroll { overflow: hidden; }
    .overlay-content {
      display: flex; gap: 1rem;
      justify-content: center; width: 100%;
      height: 100%;
    }
    .left-column {
      flex: 0 0 12.5%; position: relative;
      display: flex; flex-direction: column; align-items: flex-start;
      padding-top: 1rem;
    }
    .left-column .close-arrow {
      margin-left: 0; /* align left */
    }
    .overlay-live-icons {
      margin-top: 1rem;
      display: flex; flex-direction: column; gap: 0.5rem;
      align-items: center;
    }
    .overlay-live-icons img {
      width: 40px; height: 40px; border-radius: 50%;
      object-fit: cover; border: 2px solid var(--text-primary);
      cursor: pointer;
    }
    .video-left {
      flex: 0 0 75%; display: flex;
      flex-direction: column; overflow-y: auto;
      padding-right: 1rem; /* leave room so scrollbar doesn't overlap */
      max-height: 100%;
    }
    .video-wrapper-container {
      position: relative;
      width: 100%; aspect-ratio: 16/9;
      border-radius: 8px; overflow: hidden;
      background: #000; flex-shrink: 0;
      margin-bottom: 1rem;
    }
    iframe, video {
      width: 100%; height: 100%; border: none;
      background: #000;
    }
    .video-info {
      background: var(--bg-info); padding: 1rem;
      border-radius: 8px; width: 100%;
      overflow-y: auto; scrollbar-width: none;
      flex-shrink: 0; margin-bottom: 1rem;
    }
    .video-info::-webkit-scrollbar { width: 0; height: 0; }
    .video-info h2 {
      margin: 0 0 0.5rem; font-size: 1.2rem;
      color: var(--text-primary);
    }
    .video-info p {
      white-space: pre-wrap; margin: 0;
      color: var(--text-secondary); line-height: 1.4;
    }
    .video-info a {
      color: var(--text-accent); text-decoration: underline;
      cursor: pointer;
    }
    .read-more-button {
      color: var(--text-secondary); background: none;
      border: none; font-size: 0.9rem; cursor: pointer;
      margin-top: 0.5rem; padding: 0;
    }
    .read-more-button:hover { text-decoration: underline; }

    /* ── RIGHT COLUMN (unlimited queue) ── */
    .video-right {
      flex: 0 0 12.5%;
      display: flex; flex-direction: column; gap: 0.75rem;
      height: 100%;
      overflow-y: auto;
      padding-right: 0.5rem; /* ensure scrollbar doesn’t overlap */
    }
    .video-right::-webkit-scrollbar { width: 6px; }
    .video-right::-webkit-scrollbar-thumb {
      background: rgba(200, 200, 200, 0.3); border-radius: 3px;
    }
    .video-right .entry-card {
      width: 100%;
      aspect-ratio: 16/9;
      position: relative; border-radius: 8px; overflow: hidden;
      background: var(--bg-card);
      display: flex; align-items: flex-end;
      min-height: 12.5%;
    }
    .video-right .entry-card .thumbnail-wrapper {
      width: 100%; position: absolute; padding-top: 56.25%; overflow: hidden;
      background: #000; flex-shrink: 0;
    }
    .video-right .entry-card .thumbnail-wrapper img {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;
      display: block;
    }
    .video-right .entry-card p {
      background: var(--overlay-text-bg); margin: 0; padding: 0.3rem; font-size: 0.7rem;
      color: var(--text-primary); width: 100%; text-align: center; white-space: nowrap;
      text-overflow: ellipsis; overflow: hidden; position: relative;
    }
    .video-right .entry-card .channel-label {
      position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.7); color: var(--text-secondary);
      font-size: 0.6rem; padding: 0.1rem 0.3rem; border-radius: 4px; max-width: 85%;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .video-right .entry-card.watching::after {
      content: "Watching"; position: absolute; top: 6px; left: 6px; background: rgba(60,0,60,0.7);
      color: var(--text-primary); padding: 0.15rem 0.3rem; font-size: 0.6rem; border-radius: 4px;
    }
    .video-right .entry-card.watching {
      opacity: 0.6; pointer-events: none;
    }

    /* ── TOAST NOTIFICATION (for “Patreon skipped”) ── */
    #toast {
      position: fixed; top: 1rem; right: 1rem;
      background: var(--toast-bg); color: var(--toast-text);
      padding: 0.75rem 1rem; border-radius: 4px;
      font-size: 0.9rem; opacity: 0; pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 20000;
    }
    #toast.show {
      opacity: 1;
    }

    /* ── MANAGE FEEDS PANEL & BACKDROP ── */
    #manageBackdrop {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: var(--bg-backdrop);
      z-index: 1600; display: none;
    }
    #manageBackdrop.show { display: block; }
    #managePanel {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-side-menu); border-radius: 8px; padding: 1.5rem;
      width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
      z-index: 1601; box-sizing: border-box; display: none;
    }
    #managePanel.show { display: block; }
    #managePanel h2 {
      margin-top: 0; color: var(--text-primary); font-size: 1.5rem;
    }
    .manage-feed-list {
      margin-top: 1rem; display: flex; flex-direction: column; gap: 1rem;
    }
    .manage-feed-item {
      background: var(--bg-card); border-radius: 8px; padding: 0.75rem;
      display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;
    }
    .manage-feed-item input[type="text"] {
      flex: 2; background: #222; color: var(--text-primary); margin-right: 0.5rem;
    }
    .manage-feed-item select {
      flex: 1; background: #222; color: var(--text-primary); margin-right: 0.5rem;
    }
    .manage-feed-item label {
      display: flex; align-items: center; color: var(--text-primary);
      font-size: 0.9rem; margin-right: 0.5rem;
    }
    .manage-feed-item input[type="checkbox"] {
      margin-right: 0.25rem; cursor: pointer;
    }
    .manage-feed-item button {
      background: #cc3333; color: #fff; border: none; border-radius: 4px;
      padding: 0.4rem 0.8rem; cursor: pointer; transition: background 0.2s ease;
    }
    .manage-feed-item button:hover {
      background: #aa1111;
    }

    /* ── TWITCH QUEUE UI (v0.43) ── */
    #twitchContainer {
      padding: 1rem;
    }
    #twitchControls {
      display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;
      margin-bottom: 1rem;
    }
    #twitchControls input[type="text"] {
      padding: 0.5rem; border: none; border-radius: 4px;
      background: #330033; color: var(--text-primary); flex: 1;
    }
    #twitchControls button {
      background: var(--bg-button); color: var(--text-primary);
      border: none; border-radius: 4px; padding: 0.5rem 1rem;
      cursor: pointer; transition: background 0.2s ease;
    }
    #twitchControls button:hover {
      background: var(--bg-button-hover);
    }

    /* Draggable circle icons */
    #twitchList {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }
    .twitch-icon-item {
      cursor: grab;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--text-primary);
      transition: transform 0.15s ease;
    }
    .twitch-icon-item.drag-active {
      opacity: 0.6;
      transform: scale(1.1);
    }
    .twitch-icon-item.drag-over {
      outline: 2px dashed var(--text-accent);
    }
    .twitch-icon-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
      pointer-events: none;
      user-select: none;
    }

    #twitchPlayerContainer {
      margin-top: 1.5rem;
      width: 100%; max-width: 800px; aspect-ratio: 16/9;
      background: #000; border-radius: 8px; overflow: hidden;
      position: relative;
    }
    #twitchPlayerContainer iframe {
      width: 100%; height: 100%; border: none;
    }
    #twitchStatus {
      margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);
    }

    /* ── POP‐IN ANIMATION FOR RSS ITEMS ── */
    @keyframes popIn {
      0% { transform: scale(0); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .pop-in {
      animation: popIn 0.3s ease-out;
    }
  </style>
</head>
<body>
  <!-- ── LIVE BAR ── -->
  <div id="liveBar"></div>

  <!-- ── SIDE MENU BACKDROP ── -->
  <div id="sideBackdrop" onclick="closeSideMenu()"></div>

  <!-- ── SIDE MENU (BURGER) ── -->
  <div id="sideMenu">
    <button class="close-arrow" onclick="closeSideMenu()">←</button>
    <h2>Menu</h2>
    <div class="side-controls">
      <input
        type="text"
        id="rssUrl"
        placeholder="Paste RSS Feed URLs (comma-separated)"
      />
      <select id="folderSelect">
        <option value="">Uncategorized</option>
      </select>
      <button onclick="addFeed()">+ Add Feed(s)</button>
      <input type="text" id="newFolderName" placeholder="New Folder Name" />
      <button onclick="addFolder()">+ Add Folder</button>

      <button onclick="showManageFeeds()">Manage Feeds</button>
      <button onclick="clearAllCache()" style="background: #cc0000;">
        Clear Everything
      </button>
      <button onclick="clearVideoCache()" style="background: #cc0000;">
        Clear Videos
      </button>

      <!-- Download Log moved into burger menu -->
      <button onclick="downloadLog()" style="background: #444; color: var(--text-primary);">
        Download Log
      </button>
    </div>
  </div>

  <!-- ── HEADER with Version, Main Tabs, Filters & Refresh ── -->
  <div class="header">
    <div class="version-label">v0.43</div>
    <button class="burger-button" onclick="toggleSideMenu()">☰</button>
    <div class="main-tabs">
      <button id="tabRSS" class="active">RSS Feeds</button>
      <button id="tabTwitch">Twitch Queue</button>
    </div>
    <div class="filter-checkboxes" id="filterContainer">
      <label><input type="checkbox" id="filterYouTube" checked> YouTube</label>
      <label><input type="checkbox" id="filterPatreon" checked> Patreon</label>
      <label><input type="checkbox" id="filterAudio" checked> Hide Audio</label>
      <label><input type="checkbox" id="filterShort" checked> Hide Shorts</label>
    </div>
    <div class="filter-categories">
      <button id="btnNew">New</button>
      <button id="btnOld">Unwatched</button>
      <button id="btnWatched">Watched</button>
    </div>
    <button class="refresh-button" id="btnRefresh">Refresh Feed</button>
  </div>

  <!-- ── RSS Tab Content (unchanged) ── -->
  <div id="rssContainer" class="tab-content active">
    <div id="mainContent">
      <div id="feedsContainer"></div>
    </div>
  </div>

  <!-- ── Twitch Queue Tab Content ── -->
  <div id="twitchContainer" class="tab-content">
    <h2>Twitch Queue</h2>
    <div id="twitchControls">
      <input type="text" id="twitchChannelInput" placeholder="Add Twitch Channel (e.g. ninja)" />
      <button onclick="addTwitchChannel()">+ Add Channel</button>
    </div>
    <div id="twitchList">
      <!-- Draggable avatar icons will be inserted here -->
    </div>
    <div id="twitchPlayerContainer"></div>
    <div id="twitchStatus"></div>
  </div>

  <!-- ── TOAST (for “Patreon skipped”) ── -->
  <div id="toast"></div>

  <!-- ── PLAYER OVERLAY (RSS) ── -->
  <div class="player-overlay" id="playerOverlay" onclick="overlayClick(event)">
    <div class="overlay-content">
      <div class="left-column">
        <button
          class="close-arrow"
          onclick="closeOverlay(); event.stopPropagation();"
        >←</button>
        <div class="overlay-live-icons" id="overlayLiveIcons"></div>
      </div>
      <div class="video-left">
        <div class="video-wrapper-container" id="videoContainer"></div>
        <div class="video-info">
          <h2 id="videoTitle"></h2>
          <p id="videoDesc"></p>
          <button
            class="read-more-button"
            id="readMoreBtn"
            onclick="toggleDescription()"
          >Read More</button>
        </div>
      </div>
      <div class="video-right" id="queueList"></div>
    </div>
  </div>

  <!-- ── MANAGE FEEDS PANEL & BACKDROP ── -->
  <div id="manageBackdrop" onclick="closeManageFeeds()"></div>
  <div id="managePanel">
    <div class="manage-feeds-header">
      <h2>Manage Your Feeds</h2>
      <button onclick="closeManageFeeds()">×</button>
    </div>
    <div class="manage-feed-list" id="manageFeedList"></div>
  </div>

  <script>
    /**************************************
     *  BASIC LOGGING
     **************************************/
    const logEntries = [];
    function addLog(message) {
      const timestamp = new Date().toISOString();
      logEntries.push(`[${timestamp}] ${message}`);
    }
    function downloadLog() {
      if (!logEntries.length) {
        alert("No log entries to download.");
        return;
      }
      const blob = new Blob([logEntries.join("\n")], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "rss-reader-log.txt";
      a.click();
      URL.revokeObjectURL(url);
    }

    /**************************************
     *  PERSISTENT STORES & INITIAL STATE
     **************************************/
    let videoHistory = JSON.parse(localStorage.getItem("rssVideoHistory")) || {};
    let videoStore = JSON.parse(localStorage.getItem("rssVideoStore")) || {};
    let watchedVideos = JSON.parse(localStorage.getItem("watchedVideos")) || [];
    let feeds = JSON.parse(localStorage.getItem("rssFeeds")) || [];
    let folders = JSON.parse(localStorage.getItem("rssFolders")) || [];

    let twitchChannels = JSON.parse(localStorage.getItem("twitchChannels")) || [];
    // twitchChannels: array of { name: "channel_name", priority: number, live: bool, avatar: string }

    let videoQueue = [];
    let currentVideoIndex = -1;
    let fullDescription = "";
    let showingFull = false;
    let currentCategory = "New"; // 'New','Unwatched','Watched'

    let ytPlayer = null;
    let wasFullscreen = false;

    function saveAll() {
      localStorage.setItem("rssFeeds", JSON.stringify(feeds));
      localStorage.setItem("rssFolders", JSON.stringify(folders));
      localStorage.setItem("rssVideoHistory", JSON.stringify(videoHistory));
      localStorage.setItem("rssVideoStore", JSON.stringify(videoStore));
      localStorage.setItem("watchedVideos", JSON.stringify(watchedVideos));
      localStorage.setItem("twitchChannels", JSON.stringify(twitchChannels));
      addLog("Saved all data to localStorage.");
    }

    /**************************************
     *  UI: Main‐Tab Switching
     **************************************/
    const btnRSS = document.getElementById("tabRSS");
    const btnTwitch = document.getElementById("tabTwitch");
    const rssContainer = document.getElementById("rssContainer");
    const twitchContainer = document.getElementById("twitchContainer");

    btnRSS.addEventListener("click", () => {
      btnRSS.classList.add("active");
      btnTwitch.classList.remove("active");
      rssContainer.classList.add("active");
      twitchContainer.classList.remove("active");
    });
    btnTwitch.addEventListener("click", () => {
      btnTwitch.classList.add("active");
      btnRSS.classList.remove("active");
      twitchContainer.classList.add("active");
      rssContainer.classList.remove("active");
    });

    /**************************************
     *  LIVE BAR (Twitch Icons)
     **************************************/
    async function updateLiveBar() {
      const bar = document.getElementById("liveBar");
      bar.innerHTML = "";
      for (const c of twitchChannels) {
        if (c.live) {
          const avatarUrl = c.avatar ||
            `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
          const icon = document.createElement("img");
          icon.src = avatarUrl;
          icon.title = c.name;
          icon.onclick = () => {
            btnTwitch.click();
            currentTwitchChannel = c.name;
            playTwitchChannel(c.name);
          };
          bar.appendChild(icon);
        }
      }
    }

    async function updateOverlayLiveIcons() {
      const container = document.getElementById("overlayLiveIcons");
      container.innerHTML = "";
      for (const c of twitchChannels) {
        if (c.live) {
          const avatarUrl = c.avatar ||
            `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
          const icon = document.createElement("img");
          icon.src = avatarUrl;
          icon.title = c.name;
          icon.onclick = () => {
            btnTwitch.click();
            currentTwitchChannel = c.name;
            playTwitchChannel(c.name);
          };
          container.appendChild(icon);
        }
      }
    }

    // Update live bar and overlay‐live icons every 30s
    setInterval(() => {
      updateLiveBar();
      updateOverlayLiveIcons();
    }, 30 * 1000);
    updateLiveBar();
    updateOverlayLiveIcons();

    /**************************************
     *  RSS FEEDS CODE (v0.43; unchanged)
     **************************************/
    function clearAllCache() {
      if (!confirm("Clear ALL data including feeds?")) return;
      localStorage.clear();
      feeds = [];
      folders = [];
      videoHistory = {};
      videoStore = {};
      watchedVideos = [];
      document.getElementById("feedsContainer").innerHTML = "";
      updateFolderDropdown();
      addLog("Cleared entire cache (feeds, video history, store, watched list).");
      initialRender();
      parseFeeds(); // restart parse on empty store
    }
    function clearVideoCache() {
      if (!confirm("Clear only saved video info?")) return;
      videoHistory = {};
      videoStore = {};
      watchedVideos = [];
      localStorage.removeItem("rssVideoHistory");
      localStorage.removeItem("rssVideoStore");
      localStorage.removeItem("watchedVideos");
      addLog("Cleared video history, store, and watched list (but kept feed URLs).");
      initialRender();
      parseFeeds();
    }
    function toggleSideMenu() {
      document.getElementById("sideMenu").classList.toggle("open");
      document.getElementById("sideBackdrop").classList.toggle("show");
    }
    function closeSideMenu() {
      document.getElementById("sideMenu").classList.remove("open");
      document.getElementById("sideBackdrop").classList.remove("show");
    }
    function addFolder() {
      const name = document.getElementById("newFolderName").value.trim();
      if (name && !folders.includes(name)) {
        folders.push(name);
        updateFolderDropdown();
        saveAll();
        addLog(`Added new folder: "${name}".`);
        initialRender();
      }
      document.getElementById("newFolderName").value = "";
    }
    function updateFolderDropdown() {
      const select = document.getElementById("folderSelect");
      select.innerHTML = `<option value="">Uncategorized</option>`;
      folders.forEach((f) => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
    }
    function addFeed() {
      const raw = document.getElementById("rssUrl").value.trim();
      if (!raw) {
        alert("Please enter a valid RSS feed URL.");
        return;
      }
      const folder = document.getElementById("folderSelect").value;
      const parts = raw.split(",").map((s) => s.trim()).filter((s) => s);
      parts.forEach((url) => {
        if (feeds.some((f) => f.url === url)) {
          addLog(`Skipped adding duplicate feed: ${url}`);
          return;
        }
        feeds.push({
          url,
          folder,
          shortFilter: false,
          name: url, // Placeholder until we parse
        });
        addLog(`Added feed: ${url} (folder: "${folder}")`);
      });
      saveAll();
      initialRender();
      parseFeeds();
      document.getElementById("rssUrl").value = "";
      closeSideMenu();
    }
    function isLetterboxedThumbnail(url) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const topRow = ctx.getImageData(0, 0, canvas.width, 1).data;
          const bottomRow = ctx.getImageData(0, canvas.height - 1, canvas.width, 1).data;
          function isRowMostlyBlack(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i += 4) {
              sum += data[i] + data[i + 1] + data[i + 2];
            }
            const avg = sum / (data.length / 4);
            return avg < 20;
          }
          const topBlack = isRowMostlyBlack(topRow);
          const bottomBlack = isRowMostlyBlack(bottomRow);
          resolve(topBlack && bottomBlack);
        };
        img.onerror = () => {
          addLog(`Thumbnail load error: ${url}`);
          resolve(false);
        };
        img.src = url;
      });
    }

    // Show a brief toast message
    function showToast(msg) {
      const toast = document.getElementById("toast");
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toast._hideTimeout);
      toast._hideTimeout = setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }

    // INITIAL RENDER: show everything already in videoStore
    function initialRender() {
      updateFolderDropdown();
      document.getElementById("feedsContainer").innerHTML = "";
      buildQueueFromStore();
      const watchedSet = new Set(watchedVideos);

      // Partition into categories:
      const newUnwatched = [];
      const oldUnwatched = [];
      const watchedList = [];
      const currentIDsSet = new Set();
      Object.entries(videoHistory).forEach(([feedUrl, arr]) => {
        arr.forEach((vid) => currentIDsSet.add(vid));
      });
      videoQueue.forEach((entry) => {
        const vid = entry.id;
        const inCurrent = currentIDsSet.has(vid);
        const isWatched = watchedSet.has(vid);
        if (isWatched) {
          watchedList.push(vid);
        } else if (inCurrent) {
          newUnwatched.push(vid);
        } else {
          oldUnwatched.push(vid);
        }
      });
      function sortByDateDesc(arr) {
        return arr.sort((a, b) => {
          const da = new Date(videoStore[a].date);
          const db = new Date(videoStore[b].date);
          return db - da;
        });
      }
      sortByDateDesc(newUnwatched);
      sortByDateDesc(oldUnwatched);
      sortByDateDesc(watchedList);

      const container = document.getElementById("feedsContainer");
      container.innerHTML = "";

      const categories = [
        { key: "New", title: `New (Unwatched) (${newUnwatched.length})`, ids: newUnwatched, css: "new-cat" },
        { key: "Unwatched", title: `Old Unwatched (${oldUnwatched.length})`, ids: oldUnwatched, css: "old-cat" },
        { key: "Watched", title: `Watched (${watchedList.length})`, ids: watchedList, css: "watched-cat" }
      ];

      categories.forEach(({ title, ids, css }) => {
        const block = document.createElement("div");
        block.className = `category-block ${css}`;
        block.dataset.category = css;
        block.innerHTML = `<h2>${title}</h2><div class="entry-grid"></div>`;
        container.appendChild(block);
        const grid = block.querySelector(".entry-grid");

        ids.forEach((vid) => {
          const data = videoStore[vid];
          const isWatched = watchedSet.has(vid);
          const div = document.createElement("div");
          div.setAttribute("data-id", vid);
          div.className = "entry-card" + (isWatched ? " watching" : "") + " pop-in";
          div.innerHTML = `
            <div class="channel-label">${data.authorName}</div>
            <div class="thumbnail-wrapper">
              <img src="${data.thumbnail}" alt="Thumbnail" />
            </div>
            <p title="${data.title}">${data.title}</p>
          `;
          // Patreon items open link externally; YouTube expands in-app
          if (data.feedUrl.includes("patreon.com")) {
            div.onclick = () => window.open(data.link, "_blank");
          } else {
            div.onclick = () => expandVideoByID(vid);
          }
          grid.appendChild(div);
        });
      });

      applyCategoryFilter();
      addLog(`Initial render: ${videoQueue.length} items from store.`);
    }

    // Rebuild videoQueue purely from current videoStore (used in initial render)
    function buildQueueFromStore() {
      videoQueue = [];
      const allIDs = Object.keys(videoStore);
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;

      allIDs.forEach((vid) => {
        const data = videoStore[vid];
        const isYouTube = data.feedUrl.includes("youtube.com");
        const isPatreon = data.feedUrl.includes("patreon.com");

        // SKIP Patreon in the main queue (so it never appears in the “Up Next”)
        if (isPatreon) return;

        // 1) Source filter
        if (isYouTube && !chkYouTube) return;
        if (isPatreon && !chkPatreon) return;

        // 2) Audio filter
        if (data.entryType === "audio" && chkHideAudio) return;

        // 3) Shorts filter
        if (data.isShort && chkHideShortsGlobal) return;

        // 4) Must be a “video” entry
        if (data.entryType !== "video") return;

        videoQueue.push({
          id: vid,
          title: data.title,
          embedUrl: data.embedUrl,
          link: data.link,
          desc: data.desc,
          feedUrl: data.feedUrl,
        });
      });

      videoQueue.sort((a, b) => {
        const da = new Date(videoStore[a.id].date);
        const db = new Date(videoStore[b.id].date);
        return db - da;
      });
    }

    // PARSE FEEDS: fetch each feed; on each NEW video, append to UI
    async function parseFeeds() {
      addLog("Starting feed parsing phase...");
      const currentFeedSet = new Set();

      for (const feedObj of feeds) {
        const feedUrl = feedObj.url;
        const hideShortsForThisFeed = feedObj.shortFilter;
        if (!videoHistory[feedUrl]) {
          videoHistory[feedUrl] = [];
        }
        let xml;
        try {
          let proxyUrl;
          if (feedUrl.includes("patreon.com/rss/")) {
            proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(feedUrl)}`;
            addLog(`Fetching Patreon feed via CodeTabs proxy: ${feedUrl}`);
            const res = await fetch(proxyUrl);
            const xmlText = await res.text();
            xml = new DOMParser().parseFromString(xmlText, "application/xml");
          } else {
            proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(feedUrl)}`;
            addLog(`Fetching feed via AllOrigins /get proxy: ${feedUrl}`);
            const res = await fetch(proxyUrl);
            const data = await res.json();
            xml = new DOMParser().parseFromString(data.contents, "application/xml");
          }
        } catch (err) {
          addLog(`FETCH ERROR for ${feedUrl}: ${err}`);
          continue; // silently continue on fetch failure
        }
        let feedTitle = feedObj.name || feedUrl;
        const titleEl = xml.querySelector("channel > title, entry > author > name");
        if (titleEl) feedTitle = titleEl.textContent.trim();
        feedObj.name = feedTitle;
        addLog(`Parsing feed "${feedTitle}" (${feedUrl})`);
        const entries = xml.querySelectorAll("entry, item");

        for (const entry of entries) {
          const title = entry.querySelector("title")?.textContent.trim() || "Untitled";
          let link = "";
          const linkEl = entry.querySelector("link");
          if (linkEl) {
            if (linkEl.getAttribute("href")) link = linkEl.getAttribute("href");
            else link = linkEl.textContent.trim();
          }
          let desc = "";
          const mediaDesc = entry.querySelector("media\\:group yt\\:description");
          const rssDesc = entry.querySelector("description");
          const contentEncoded = entry.querySelector("content\\:encoded");
          if (mediaDesc) desc = mediaDesc.textContent.trim();
          else if (contentEncoded) desc = contentEncoded.textContent.trim();
          else if (rssDesc) desc = rssDesc.textContent.trim();
          const entryAuthorEl = entry.querySelector("author > name");
          const entryAuthor = entryAuthorEl?.textContent.trim() || feedTitle;
          let dateText = "";
          if (entry.querySelector("published")) dateText = entry.querySelector("published").textContent;
          else if (entry.querySelector("pubDate")) dateText = entry.querySelector("pubDate").textContent;
          else if (entry.querySelector("updated")) dateText = entry.querySelector("updated").textContent;
          const publishedDate = dateText ? new Date(dateText) : new Date();

          let uniqueId, embedUrl = null, entryType = "video", isShort = false;
          if (link.includes("youtube.com/watch?v=")) {
            const videoId = new URL(link).searchParams.get("v");
            const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
            const letterboxed = await isLetterboxedThumbnail(thumbnailUrl);
            isShort = !letterboxed;
            uniqueId = videoId;
            currentFeedSet.add(videoId);

            if (!videoHistory[feedUrl].includes(videoId)) {
              // It’s truly new:
              videoHistory[feedUrl].push(videoId);
              addLog(`New YouTube video ID: ${videoId}`);

              const dataObj = {
                title,
                embedUrl: `https://www.youtube.com/embed/${videoId}`,
                link,
                desc,
                thumbnail: thumbnailUrl,
                date: publishedDate.toISOString(),
                feedName: feedTitle,
                authorName: entryAuthor,
                feedUrl,
                isShort,
                entryType: "video"
              };
              videoStore[videoId] = dataObj;
              saveAll();

              // Immediately append its card to the correct category:
              appendVideoCard(videoId);
            } else {
              // Already known—update metadata if changed
              const existing = videoStore[videoId] || {};
              videoStore[videoId] = {
                ...existing,
                title,
                embedUrl: `https://www.youtube.com/embed/${videoId}`,
                link,
                desc,
                thumbnail: thumbnailUrl,
                date: publishedDate.toISOString(),
                feedName: feedTitle,
                authorName: entryAuthor,
                feedUrl,
                isShort,
                entryType: "video"
              };
            }
          } else {
            // Non-YouTube entry (Patreon or generic RSS)
            const guidNode = entry.querySelector("guid");
            uniqueId = feedUrl + "|" + (guidNode?.textContent.trim() || Math.random().toString(36).substr(2, 9));
            currentFeedSet.add(uniqueId);

            if (!videoHistory[feedUrl].includes(uniqueId)) {
              videoHistory[feedUrl].push(uniqueId);
              addLog(`New generic entry ID: ${uniqueId} from ${feedUrl}`);

              let thumbUrl = "";
              let isAudio = false;

              // ── P A T R E O N   L O G I C ──
              if (feedUrl.includes("patreon.com")) {
                // Treat all Patreon posts as video unless "audio" in title
                if (/audio/i.test(title)) {
                  entryType = "audio";
                  isAudio = true;
                  addLog(`Patreon post tagged as audio (matched "audio" in title): "${title}" → ${uniqueId}`);
                } else {
                  entryType = "video";
                  embedUrl = null; // Patreon cannot embed inline
                  addLog(`Patreon post treated as video (no "audio" in title): "${title}" → ${uniqueId}`);
                }
              } else {
                // ── G E N E R I C   R S S ──
                const enc = entry.querySelector("enclosure");
                if (enc) {
                  const encType = enc.getAttribute("type") || "";
                  const encUrl = enc.getAttribute("url") || "";
                  if (encType.startsWith("audio")) {
                    entryType = "audio";
                    isAudio = true;
                  } else if (encType.startsWith("video")) {
                    entryType = "video";
                    embedUrl = encUrl;
                    addLog(`Detected generic video enclosure for ${uniqueId}: ${encUrl}`);
                  }
                }
              }

              // ―――――――――――――――――――――――
              // Find a thumbnail (<itunes:image> or <media:thumbnail>)
              const itunesImgNodes = entry.getElementsByTagNameNS(
                "http://www.itunes.com/dtds/podcast-1.0.dtd", "image"
              );
              if (itunesImgNodes.length > 0) {
                thumbUrl = itunesImgNodes[0].getAttribute("href") || "";
                addLog(`Found <itunes:image> for ${uniqueId}: ${thumbUrl}`);
              } else {
                const mediaThumb = entry.querySelector("media\\:thumbnail");
                if (mediaThumb) {
                  thumbUrl = mediaThumb.getAttribute("url") || "";
                  addLog(`Found <media:thumbnail> for ${uniqueId}: ${thumbUrl}`);
                } else {
                  addLog(`No thumbnail found for ${uniqueId}`);
                }
              }

              const dataObj = {
                title,
                embedUrl,
                link,
                desc,
                thumbnail: thumbUrl,
                date: publishedDate.toISOString(),
                feedName: feedTitle,
                authorName: entryAuthor,
                feedUrl,
                isShort: false,
                entryType
              };
              videoStore[uniqueId] = dataObj;
              saveAll();

              // Immediately append its card (respecting filters and sorted):
              appendVideoCard(uniqueId);
            } else {
              // Already known—update metadata if needed
              const existing = videoStore[uniqueId] || {};
              videoStore[uniqueId] = {
                ...existing,
                title,
                embedUrl: existing.embedUrl,
                link,
                desc,
                thumbnail: existing.thumbnail,
                date: publishedDate.toISOString(),
                feedName: feedTitle,
                authorName: entryAuthor,
                feedUrl,
                isShort: false,
                entryType: existing.entryType || "video"
              };
            }
          }
        }
      }

      addLog("Finished parsing all feeds.");
    }

    // Append a single new video card to whichever category it belongs to,
    // and insert it in sorted order by date within that category.
    function appendVideoCard(videoId) {
      const data = videoStore[videoId];
      const isYouTube = data.feedUrl.includes("youtube.com");
      const isPatreon = data.feedUrl.includes("patreon.com");
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;
      const hideShortsForFeed = feeds.find(f => f.url === data.feedUrl)?.shortFilter;

      // 1) Source filter
      if (isYouTube && !chkYouTube) return;
      if (isPatreon && !chkPatreon) return;

      // 2) Audio filter
      if (data.entryType === "audio" && chkHideAudio) return;

      // 3) Shorts filter
      if (data.isShort && (chkHideShortsGlobal || hideShortsForFeed)) return;

      // 4) Must be a “video” entry
      if (data.entryType !== "video") return;

      // Determine category: new vs old vs watched
      const watchedSet = new Set(watchedVideos);
      const inCurrentFeed = videoHistory[data.feedUrl]?.includes(videoId);
      let categoryClass;
      if (watchedSet.has(videoId)) {
        categoryClass = "watched-cat";
      } else if (inCurrentFeed) {
        categoryClass = "new-cat";
      } else {
        categoryClass = "old-cat";
      }

      // Find or create the category-block
      let block = document.querySelector(`.category-block.${categoryClass}`);
      let grid, header;
      if (!block) {
        // Create a new category-block if it doesn’t exist yet
        const container = document.getElementById("feedsContainer");
        const newBlock = document.createElement("div");
        newBlock.className = `category-block ${categoryClass}`;
        newBlock.dataset.category = categoryClass;
        const titleText = categoryClass === "new-cat"
          ? "New (Unwatched)"
          : categoryClass === "old-cat"
            ? "Old Unwatched"
            : "Watched";
        newBlock.innerHTML = `<h2>${titleText} (1)</h2><div class="entry-grid"></div>`;
        container.appendChild(newBlock);
        grid = newBlock.querySelector(".entry-grid");
        header = newBlock.querySelector("h2");
      } else {
        grid = block.querySelector(".entry-grid");
        header = block.querySelector("h2");
        // Increment the count in header: extract number from “(N)” and +1
        const match = header.textContent.match(/\((\d+)\)$/);
        let count = match ? parseInt(match[1], 10) : 0;
        count += 1;
        const titleText = header.textContent.replace(/\(\d+\)$/, "").trim();
        header.textContent = `${titleText} (${count})`;
      }

      // Create the new card element (but do not append yet)
      const div = document.createElement("div");
      div.setAttribute("data-id", videoId);
      const isWatched = watchedSet.has(videoId);
      div.className = "entry-card" + (isWatched ? " watching" : "") + " pop-in";
      div.innerHTML = `
        <div class="channel-label">${data.authorName}</div>
        <div class="thumbnail-wrapper">
          <img src="${data.thumbnail}" alt="Thumbnail" />
        </div>
        <p title="${data.title}">${data.title}</p>
      `;
      if (isPatreon) {
        div.onclick = () => window.open(data.link, "_blank");
      } else {
        div.onclick = () => expandVideoByID(videoId);
      }

      // Insert into 'grid' at proper sorted position by comparing dates:
      const existingCards = Array.from(grid.children);
      let inserted = false;
      for (let i = 0; i < existingCards.length; i++) {
        const existingId = existingCards[i].getAttribute("data-id");
        if (!existingId) continue;
        const existingDate = new Date(videoStore[existingId].date);
        const newDate = new Date(data.date);
        if (newDate > existingDate) {
          grid.insertBefore(div, existingCards[i]);
          inserted = true;
          break;
        }
      }
      if (!inserted) {
        grid.appendChild(div);
      }

      addLog(`Appended new card for video ${videoId} into category "${categoryClass}" (sorted).`);
    }

    // Expand video overlay and play (only for YouTube)
    function expandVideoByID(videoId) {
      if (!watchedVideos.includes(videoId)) {
        watchedVideos.push(videoId);
        saveAll();
        addLog(`Marked as watched: ${videoId}`);
      }
      // Rebuild queue, find index, play
      buildQueueFromQueueState();
      currentVideoIndex = videoQueue.findIndex((v) => v.id === videoId);
      playCurrent();
    }

    // Build videoQueue from current filters and store (for overlay’s “Up Next”)
    function buildQueueFromQueueState() {
      videoQueue = [];
      const allIDs = Object.keys(videoStore);
      const chkYouTube = document.getElementById("filterYouTube").checked;
      const chkPatreon = document.getElementById("filterPatreon").checked;
      const chkHideAudio = document.getElementById("filterAudio").checked;
      const chkHideShortsGlobal = document.getElementById("filterShort").checked;

      allIDs.forEach((vid) => {
        const data = videoStore[vid];
        const isYouTube = data.feedUrl.includes("youtube.com");
        const isPatreon = data.feedUrl.includes("patreon.com");
        const hideShortsForFeed = feeds.find(f => f.url === data.feedUrl)?.shortFilter;

        // SKIP Patreon in the overlay queue:
        if (isPatreon) return;

        // 1) Source filter
        if (isYouTube && !chkYouTube) return;
        if (isPatreon && !chkPatreon) return;

        // 2) Audio filter
        if (data.entryType === "audio" && chkHideAudio) return;

        // 3) Shorts filter
        if (data.isShort && (chkHideShortsGlobal || hideShortsForFeed)) return;

        // 4) Must be a “video” entry
        if (data.entryType !== "video") return;

        videoQueue.push({
          id: vid,
          title: data.title,
          embedUrl: data.embedUrl,
          link: data.link,
          desc: data.desc,
          feedUrl: data.feedUrl,
        });
      });

      videoQueue.sort((a, b) => {
        const da = new Date(videoStore[a.id].date);
        const db = new Date(videoStore[b.id].date);
        return db - da;
      });
    }

    function playCurrent() {
      if (currentVideoIndex < 0 || currentVideoIndex >= videoQueue.length) {
        closeOverlay();
        return;
      }
      const entry = videoQueue[currentVideoIndex];
      openOverlay(entry);
    }

    function openOverlay({ id, title, embedUrl, desc }) {
      wasFullscreen = !!document.fullscreenElement;
      document.body.classList.add("no-scroll");
      document.getElementById("playerOverlay").classList.add("show");
      if (ytPlayer) {
        ytPlayer.destroy();
        ytPlayer = null;
      }
      const container = document.getElementById("videoContainer");
      container.innerHTML = "";
      const ytDiv = document.createElement("div");
      ytDiv.id = "yt-player";
      container.appendChild(ytDiv);
      const videoId = new URL(embedUrl).pathname.split("/").pop();
      ytPlayer = new YT.Player("yt-player", {
        videoId: videoId,
        playerVars: {
          autoplay: 1,
          rel: 0,
          playsinline: 1
        },
        events: {
          onReady: (event) => {
            if (wasFullscreen) {
              const overlayEl = document.getElementById("playerOverlay");
              if (overlayEl.requestFullscreen) {
                overlayEl.requestFullscreen().catch(() => {/*ignore*/});
              } else if (overlayEl.webkitRequestFullscreen) {
                overlayEl.webkitRequestFullscreen();
              }
            }
          },
          onStateChange: onPlayerStateChange
        }
      });
      document.getElementById("videoTitle").textContent = title;
      fullDescription = desc;
      showingFull = false;
      const descEl = document.getElementById("videoDesc");
      const btn = document.getElementById("readMoreBtn");
      if (fullDescription.length <= 300) {
        descEl.innerHTML = fullDescription.replace(/\n/g, "<br>");
        btn.style.display = "none";
      } else {
        descEl.innerHTML = fullDescription.slice(0, 300).replace(/\n/g, "<br>") + "...";
        btn.textContent = "Read More";
        btn.style.display = "inline";
      }
      renderQueueSidebar();
      updateOverlayLiveIcons();
      addLog(`Now playing YouTube video: ${id}`);
    }

    function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.ENDED) {
        addLog("YouTube video ended; advancing queue.");
        currentVideoIndex++;
        playCurrent();
      }
    }

    function toggleDescription() {
      const descEl = document.getElementById("videoDesc");
      const btn = document.getElementById("readMoreBtn");
      if (showingFull) {
        descEl.innerHTML = fullDescription.slice(0, 300).replace(/\n/g, "<br>") + "...";
        btn.textContent = "Read More";
      } else {
        descEl.innerHTML = fullDescription.replace(/\n/g, "<br>");
        btn.textContent = "Show Less";
      }
      showingFull = !showingFull;
    }

    function renderQueueSidebar() {
      const queueElem = document.getElementById("queueList");
      queueElem.innerHTML = "";
      const watchedSet = new Set(watchedVideos);

      // Current video card at top
      if (currentVideoIndex >= 0 && currentVideoIndex < videoQueue.length) {
        const currentId = videoQueue[currentVideoIndex].id;
        const data = videoStore[currentId];
        const card = document.createElement("div");
        card.setAttribute("data-id", currentId);
        card.className = "entry-card watching pop-in";
        card.innerHTML = `
          <div class="thumbnail-wrapper">
            <img src="${data.thumbnail}" alt="Thumbnail" />
          </div>
          <p title="${data.title}">${data.title}</p>
        `;
        queueElem.appendChild(card);
      }

      // All future videos
      videoQueue.forEach((entry, idx) => {
        if (idx <= currentVideoIndex) return;
        const data = videoStore[entry.id];
        const isWatched = watchedSet.has(entry.id);
        const div = document.createElement("div");
        div.setAttribute("data-id", entry.id);
        div.className = "entry-card" + (isWatched ? " watching" : "") + " pop-in";
        div.innerHTML = `
          <div class="thumbnail-wrapper">
            <img src="${data.thumbnail}" alt="Thumbnail" />
          </div>
          <p title="${data.title}">${data.title}</p>
        `;
        div.onclick = () => {
          currentVideoIndex = idx;
          playCurrent();
        };
        queueElem.appendChild(div);
      });
    }

    function closeOverlay() {
      document.getElementById("playerOverlay").classList.remove("show");
      document.body.classList.remove("no-scroll");
      if (ytPlayer) {
        ytPlayer.destroy();
        ytPlayer = null;
      }
      document.getElementById("videoContainer").innerHTML = "";
      currentVideoIndex = -1;
      addLog("Closed video overlay.");
    }

    function overlayClick(e) {
      if (e.target === e.currentTarget) {
        closeOverlay();
      }
    }

    function showManageFeeds() {
      closeSideMenu();
      document.getElementById("manageBackdrop").classList.add("show");
      document.getElementById("managePanel").classList.add("show");
      renderManageFeedsList();
      document.body.classList.add("no-scroll");
      addLog("Opened Manage Feeds panel.");
    }

    function closeManageFeeds() {
      document.getElementById("manageBackdrop").classList.remove("show");
      document.getElementById("managePanel").classList.remove("show");
      document.body.classList.remove("no-scroll");
      addLog("Closed Manage Feeds panel.");
    }

    function renderManageFeedsList() {
      const container = document.getElementById("manageFeedList");
      container.innerHTML = "";
      if (feeds.length === 0) {
        const msg = document.createElement("p");
        msg.textContent = "No feeds added yet.";
        msg.style.color = "#ccc";
        container.appendChild(msg);
        return;
      }
      feeds.forEach((f, idx) => {
        const item = document.createElement("div");
        item.className = "manage-feed-item";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = f.name || f.url;
        nameInput.readOnly = true;
        const folderSelect = document.createElement("select");
        const uncOpt = document.createElement("option");
        uncOpt.value = "";
        uncOpt.textContent = "Uncategorized";
        folderSelect.appendChild(uncOpt);
        folders.forEach((folderName) => {
          const opt = document.createElement("option");
          opt.value = folderName;
          opt.textContent = folderName;
          folderSelect.appendChild(opt);
        });
        folderSelect.value = f.folder || "";
        folderSelect.onchange = () => {
          feeds[idx].folder = folderSelect.value;
          saveAll();
          addLog(`Changed folder for feed "${f.url}" to "${folderSelect.value}".`);
          initialRender();
        };
        const shortLabel = document.createElement("label");
        const shortCheckbox = document.createElement("input");
        shortCheckbox.type = "checkbox";
        shortCheckbox.checked = !!f.shortFilter;
        shortCheckbox.onchange = () => {
          feeds[idx].shortFilter = shortCheckbox.checked;
          saveAll();
          addLog(`Toggled shortFilter for "${f.url}" to ${shortCheckbox.checked}.`);
          initialRender();
        };
        shortLabel.appendChild(shortCheckbox);
        shortLabel.appendChild(document.createTextNode("Short Filter"));
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.onclick = () => {
          if (confirm("Delete this feed?")) {
            addLog(`Deleted feed: ${f.url}`);
            feeds.splice(idx, 1);
            saveAll();
            initialRender();
            parseFeeds();
            renderManageFeedsList();
          }
        };
        item.appendChild(nameInput);
        item.appendChild(folderSelect);
        item.appendChild(shortLabel);
        item.appendChild(delBtn);
        container.appendChild(item);
      });
    }

    function setCategory(category) {
      currentCategory = category;
      document.getElementById("btnNew").classList.toggle("active", category === "New");
      document.getElementById("btnOld").classList.toggle("active", category === "Unwatched");
      document.getElementById("btnWatched").classList.toggle("active", category === "Watched");
      // Re‐filter displayed blocks
      applyCategoryFilter();
      addLog(`Switched category filter to "${category}".`);
    }

    function applyCategoryFilter() {
      document.querySelectorAll(".category-block").forEach((block) => {
        if (
          block.classList.contains("new-cat") &&
          currentCategory !== "New"
        ) {
          block.style.display = "none";
        } else if (
          block.classList.contains("old-cat") &&
          currentCategory !== "Unwatched"
        ) {
          block.style.display = "none";
        } else if (
          block.classList.contains("watched-cat") &&
          currentCategory !== "Watched"
        ) {
          block.style.display = "none";
        } else {
          block.style.display = "";
        }
      });
    }

    document.getElementById("btnNew").addEventListener("click", () => setCategory("New"));
    document.getElementById("btnOld").addEventListener("click", () => setCategory("Unwatched"));
    document.getElementById("btnWatched").addEventListener("click", () => setCategory("Watched"));
    document.getElementById("filterYouTube").addEventListener("change", () => {
      addLog(`Toggled YouTube filter: ${document.getElementById("filterYouTube").checked}`);
      initialRender();
    });
    document.getElementById("filterPatreon").addEventListener("change", () => {
      addLog(`Toggled Patreon filter: ${document.getElementById("filterPatreon").checked}`);
      initialRender();
    });
    document.getElementById("filterAudio").addEventListener("change", () => {
      addLog(`Toggled Hide Audio: ${document.getElementById("filterAudio").checked}`);
      initialRender();
    });
    document.getElementById("filterShort").addEventListener("change", () => {
      addLog(`Toggled Hide Shorts: ${document.getElementById("filterShort").checked}`);
      initialRender();
    });

    // “Refresh Feed” button:
    document.getElementById("btnRefresh").addEventListener("click", () => {
      addLog("Manual refresh triggered.");
      parseFeeds();
    });

    updateFolderDropdown();
    setCategory("New");
    // Initial load:
    initialRender();
    // Then parse feeds to discover any new items:
    parseFeeds();
    // Re‐parse every 5 minutes:
    setInterval(parseFeeds, 5 * 60 * 1000);

    /**************************************
     *  TWITCH QUEUE CODE (v0.43)
     **************************************/
    let twitchInterval = null;
    let currentTwitchChannel = null;

    function addTwitchChannel() {
      const input = document.getElementById("twitchChannelInput");
      const name = input.value.trim().toLowerCase();
      if (!name) return;
      if (twitchChannels.some((c) => c.name === name)) {
        alert("Channel already in queue.");
        return;
      }
      const maxPrio = twitchChannels.reduce((max, c) => Math.max(max, c.priority), 0);
      twitchChannels.push({ name, priority: maxPrio + 1, live: false, avatar: null });
      saveAll();
      input.value = "";
      renderTwitchList();
    }

    // If we remove a channel, rerender:
    function removeTwitchChannel(idx) {
      twitchChannels.splice(idx, 1);
      saveAll();
      renderTwitchList();
    }

    // Recompute .priority after reorder
    function normalizePriorities() {
      twitchChannels.sort((a, b) => a.priority - b.priority);
      twitchChannels.forEach((c, i) => c.priority = i + 1);
      saveAll();
    }

    function renderTwitchList() {
      const list = document.getElementById("twitchList");
      list.innerHTML = "";
      // Sort by priority first
      twitchChannels.sort((a, b) => a.priority - b.priority);

      twitchChannels.forEach((c, idx) => {
        const item = document.createElement("div");
        item.className = "twitch-icon-item";
        item.setAttribute("data-index", idx);

        // If avatar already known, use it; otherwise fallback:
        const img = document.createElement("img");
        img.src = c.avatar ||
          `https://static-cdn.jtvnw.net/jtv_user_pictures/${c.name}-profile_image-70x70.png`;
        img.alt = c.name;
        item.appendChild(img);

        // START: Mouse‐draggable logic
        item.addEventListener("mousedown", (e) => onDragStart(e, idx));
        // END: Mouse‐draggable logic

        list.appendChild(item);
      });
    }

    // === MOUSE‐DRAG “FOLLOW CURSOR” IMPLEMENTATION ===
    let dragInfo = null; // Will hold { sourceIdx, cloneElem, initialX, initialY }

    function onDragStart(e, sourceIdx) {
      e.preventDefault();
      const original = e.currentTarget;
      const rect = original.getBoundingClientRect();

      // 1) Clone the element for dragging animation
      const clone = original.cloneNode(true);
      clone.style.position = "absolute";
      clone.style.left = `${rect.left}px`;
      clone.style.top = `${rect.top}px`;
      clone.style.width = `${rect.width}px`;
      clone.style.height = `${rect.height}px`;
      clone.style.pointerEvents = "none";
      clone.style.zIndex = 20000;
      clone.classList.add("drag-active");
      document.body.appendChild(clone);

      dragInfo = {
        sourceIdx,
        cloneElem: clone,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };

      document.addEventListener("mousemove", onDragging);
      document.addEventListener("mouseup", onDrop);
    }

    function onDragging(e) {
      if (!dragInfo) return;
      // Move the clone to follow cursor
      dragInfo.cloneElem.style.left = `${e.clientX - dragInfo.offsetX}px`;
      dragInfo.cloneElem.style.top = `${e.clientY - dragInfo.offsetY}px`;

      // Highlight potential drop target
      document.querySelectorAll(".twitch-icon-item").forEach((el) => {
        el.classList.remove("drag-over");
      });
      const under = document.elementFromPoint(e.clientX, e.clientY);
      if (under) {
        const target = under.closest(".twitch-icon-item");
        if (target && target.getAttribute("data-index") !== null) {
          target.classList.add("drag-over");
        }
      }
    }

    function onDrop(e) {
      if (!dragInfo) return;
      document.removeEventListener("mousemove", onDragging);
      document.removeEventListener("mouseup", onDrop);

      // Determine drop target
      const under = document.elementFromPoint(e.clientX, e.clientY);
      let targetIdx = null;
      if (under) {
        const target = under.closest(".twitch-icon-item");
        if (target && target.getAttribute("data-index") !== null) {
          targetIdx = parseInt(target.getAttribute("data-index"), 10);
          target.classList.remove("drag-over");
        }
      }

      // Remove the clone
      document.body.removeChild(dragInfo.cloneElem);

      const sourceIdx = dragInfo.sourceIdx;
      dragInfo = null;

      // If dropped on valid target (and different index), reorder:
      if (targetIdx !== null && targetIdx !== sourceIdx) {
        const [moved] = twitchChannels.splice(sourceIdx, 1);
        twitchChannels.splice(targetIdx, 0, moved);
        normalizePriorities();
      }

      renderTwitchList();
    }
    // =================================================

    async function checkTwitchTracker(channel) {
      // Fetch via AllOrigins to avoid CORS issues
      try {
        const proxyUrl = `https://api.allorigins.win/raw?url=https://twitchtracker.com/${channel}`;
        const res = await fetch(proxyUrl);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");

        // 1) “LIVE” check (updated selector):
        const badge = doc.querySelector(".live-indicator");
        const isLive = !!badge;

        // 2) Avatar check (updated selector):
        const logoImg = doc.querySelector("#app-logo img");
        const avatarUrl = logoImg ? logoImg.src : null;

        return { live: isLive, avatar: avatarUrl };
      } catch (err) {
        addLog(`TwitchTracker fetch error for ${channel}: ${err}`);
        return { live: false, avatar: null };
      }
    }

    async function checkTwitchAndPlay() {
      if (!twitchChannels.length) {
        document.getElementById("twitchPlayerContainer").innerHTML = "";
        document.getElementById("twitchStatus").textContent = "No channels in queue.";
        updateLiveBar();
        updateOverlayLiveIcons();
        return;
      }
      const statuses = await Promise.all(
        twitchChannels.map((c) => checkTwitchTracker(c.name))
      );
      // Merge statuses back into channels
      statuses.forEach((st, i) => {
        twitchChannels[i].live = st.live;
        twitchChannels[i].avatar = st.avatar;
      });
      // Update liveBar icons immediately
      updateLiveBar();
      updateOverlayLiveIcons();

      // Filter only live channels, sort by priority
      const liveList = twitchChannels
        .filter((c) => c.live)
        .sort((a, b) => a.priority - b.priority);
      if (!liveList.length) {
        document.getElementById("twitchPlayerContainer").innerHTML = "";
        document.getElementById("twitchStatus").textContent = "No one is live right now.";
        return;
      }
      const topLive = liveList[0].name; // highest-priority
      if (currentTwitchChannel === topLive) {
        document.getElementById("twitchStatus").textContent = `Watching ${topLive}`;
        return;
      }
      currentTwitchChannel = topLive;
      playTwitchChannel(topLive);
    }

    function playTwitchChannel(channel) {
      // Since GitHub Pages is whitelisted, use dynamic hostname:
      const parentDomain = window.location.hostname || "localhost";
      const embedUrl =
        `https://player.twitch.tv/` +
        `?channel=${encodeURIComponent(channel)}` +
        `&parent=${parentDomain}` +
        `&autoplay=true`;

      const container = document.getElementById("twitchPlayerContainer");
      container.innerHTML = `
        <iframe
          src="${embedUrl}"
          allowfullscreen="true"
          scrolling="no"
          height="100%"
          width="100%">
        </iframe>
      `;
      document.getElementById("twitchStatus").textContent = `Now watching: ${channel}`;
      addLog(`Switched to live Twitch channel: ${channel} (parent=${parentDomain})`);
    }

    function startTwitchPolling() {
      checkTwitchAndPlay();
      twitchInterval = setInterval(checkTwitchAndPlay, 30 * 1000);
      addLog("Started TwitchTracker polling every 30s.");
    }

    // Always poll Twitch in background, regardless of tab
    startTwitchPolling();
    renderTwitchList();
  </script>

  <!-- ── YouTube IFrame API ── -->
  <script src="https://www.youtube.com/iframe_api"></script>
</body>
</html>
